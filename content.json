{"meta":{"title":"花椒猫猫的小窝","subtitle":"菜鸡勿喷 0.0 ","description":"A Personal Blog To Note Someting Interesting","author":"Pepperr Cat","url":"https://peperrcat.github.io","root":"/"},"pages":[{"title":"朋友","date":"2022-04-05T13:50:48.681Z","updated":"2022-04-05T13:50:48.681Z","comments":true,"path":"PY.html","permalink":"https://peperrcat.github.io/PY.html","excerpt":"","text":"今夜我不会遇见你 今夜我遇见了世上的一切 但不会遇见你。 一棵夏季最后 火红的山楂树 象一辆高大女神的自行车 象一女孩畏惧群山 呆呆站在门口 她不会向我 跑来！ 我走过黄昏 型风吹向远处的平原 我将在暮色中抱住一棵孤独的树干 山楂树！一闪而过啊！山楂 我要在你的乳房下坐到天亮。 又小又美丽的山楂的乳房 在高大女神的自行车上 在农奴的手上 在夜晚就要熄灭 友情链接"},{"title":"文章归档","date":"2022-04-06T06:37:22.337Z","updated":"2022-04-06T05:52:07.439Z","comments":true,"path":"archive.html","permalink":"https://peperrcat.github.io/archive.html","excerpt":"","text":""},{"title":"关于","date":"2022-04-10T17:10:08.054Z","updated":"2022-04-10T17:10:08.054Z","comments":true,"path":"about.html","permalink":"https://peperrcat.github.io/about.html","excerpt":"","text":"博客事件轴 2022年04月05日 - 第一次搭建博客，使用typora作为mackdown语言编辑器，借用了nexmoe佬的模板，实在是tql！ 2022年04月11日 - 写并查集de了一晚上bug，麻中麻，睡个好觉。 …… 开源nexmoe (Nexmoe) (github.com)（聚聚的github） 目前还没想好写啥，先放在这吧哈哈哈哈哈哈。"}],"posts":[{"title":"search egine（数据结构大作业）","slug":"egine","date":"2022-04-21T16:18:13.000Z","updated":"2022-04-21T16:21:29.975Z","comments":true,"path":"2022/04/22/egine/","link":"","permalink":"https://peperrcat.github.io/2022/04/22/egine/","excerpt":"","text":"","categories":[{"name":"作业分析与实现","slug":"作业分析与实现","permalink":"https://peperrcat.github.io/categories/%E4%BD%9C%E4%B8%9A%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://peperrcat.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"栈与表达式计算","slug":"栈与表达式计算","date":"2022-04-15T08:03:51.000Z","updated":"2022-04-23T06:11:58.301Z","comments":true,"path":"2022/04/15/栈与表达式计算/","link":"","permalink":"https://peperrcat.github.io/2022/04/15/%E6%A0%88%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/","excerpt":"","text":"[TOC] 栈与表达式计算表达式表达式是我们非常常见的运算的表示形式，有包括算数运算在内的，逻辑运算等各种表达式，根据运算符（operator）位置的不同，又可以分为一下三类：前缀、中缀和后缀表达式。其中，我们最常用也是最便于人类理解的，则是中缀表达式。 中缀表达式顾名思义，中缀表达式即运算符位于运算对象中间的表达式，像1+1，2*5，3%(7+5)这种表达形式都是中缀表达式，对人类来说，其非常容易理解，但是设计优先级的问题对于机器来说则并不是很容易的进行计算。因此，人们另提出了前后缀两种表达式。 前缀与后缀表达式同样的，前后缀表达式则是运算符分别位于运算对象前后的两种表达式，如同+1 2、*3 5、6 9-、4 5%等，这些则都是前、后缀表达式，其中，在计算机领域中，又以后缀表达式运用的最为广泛，其又被称为逆波兰表达式。但为何计算机对后缀表达式的计算理解更容易呢，这就涉及到后缀表达式的运算过程了。 后缀表达式的运算其实比较简单，读取到运算符后，就对前两个数进行运算，得到的结果放在还未进行运算的数后面，也就是说，位于后方的数，在读取到运算符后，反而优先计算，这中特殊的组织数据的方式和栈类似，于是我们可以用栈来实现后缀表达式的运算。 当读取到数字的时候，我们把数字直接压栈，当读取到符号后，就把栈顶的两个数弹栈，按照运算顺序对运算符进行计算，得到的结果压栈，反复进行这一过程，直到所有的运算符计算完成，剩下栈中的最后一个数就是表达式计算的结果。因此，前后缀表达式实际上并没有括号这一符号，因为其运算顺序已经在表达式中确定了。前缀表达式实际上过程一样，只是我们读取的过程要从后往前罢了。 为了 方便理解，这里举个例子：3 4 + 5 × 6 -，从右往左读取，读到的3 4压栈，然后读到 “+” 则把3 4 计算后得到7压栈，然后继续读到5，继续压栈，读到 “×” 则把7 5弹栈计算得到35后压栈，继续读到6压栈后读到 “-” ，弹栈计算后得到29即为最后结果。 因此，我们想实现中缀表达式的计算，如果能把中缀表达式转换为后缀表达式，就能通过栈很容易得到运算结果了。 中缀表达式求值的栈实现分析及代码终极代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#define MAXSIZE 100 //栈容量typedef double DataType; //数据类型，可根据需要改变typedef enum symbol //字符枚举变量，用于getsym函数判断读入内容为数字，操作符，等号，还是其他&#123; NUM, OPE, EQU, OTH&#125; SymType;typedef enum operator //操作符枚举变量，用于入栈及根据优先级数列判断优先级&#123; AND, //与 XOR, //疑惑 OR, //或 MORE, //大于 LESS, //小于 ADD, MIN, MUL, DIV, MOD, //取模 NOT, //非 LEFT, //左括号 RIGHT //右括号&#125; OpeType;int prior[] = &#123;0, -1, -2, 1, 1, 2, 2, 3, 3, 3, 4, 5, 5&#125;; //优先级数列union sym //联合变量，用于读取操作符或数字&#123; DataType num; OpeType op;&#125;;OpeType Ope_Stack[MAXSIZE]; //符号栈int OpeTop = -1; //栈顶DataType Num_Stack[MAXSIZE]; //数组栈int NumTop = -1;SymType GetSym(union sym *item); //读取数字或运算符函数,返回值为相应的枚举类型(NUM OPE EQU OHE)void Push_Ope(OpeType op); //运算符压栈函数void Push_Num(DataType num);OpeType Pop_Ope(); //运算符压栈函数,返回值为弹栈元素枚举类型(ADD MIN MUL DIV)DataType Pop_Num();void operate(OpeType op); //操作函数,对无法压栈的字符串进行操作void calculate(OpeType op); //运算函数,对数字栈顶两元素以传入运算符进行运算int main()&#123; union sym item; //储存数字或运算符 SymType s; //判断getsym返回类型 while ((s = GetSym(&amp;item)) != EQU) //返回不为等号循环读取 &#123; if (s == NUM) //数字直接压栈 Push_Num(item.num); else if (s == OPE) //符号导入操作函数进行操作 &#123; operate(item.op); &#125; else //否则输入有问题 &#123; printf(&quot;Error Input!\\n&quot;); return 1; &#125; &#125; while (OpeTop != -1) //读取操作完成后, 把符号栈剩余符号全部弹栈计算一遍 &#123; calculate(Pop_Ope()); &#125; if (NumTop == 0) //计算完成符号栈清空,数字栈只剩一个元素,弹栈输出即可 printf(&quot;%g\\n&quot;, Pop_Num()); else //否则输入有问题 &#123; printf(&quot;Error Input!\\n&quot;); return 1; &#125;&#125;SymType GetSym(union sym *item)&#123; char c; while ((c = getchar()) != &#x27;=&#x27;) &#123; if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; for (item-&gt;num = 0; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) //多位数字处理 &#123; item-&gt;num = item-&gt;num * 10 + c - &#x27;0&#x27;; &#125; ungetc(c, stdin); //退回缓冲区,防止读入符号丢失 return NUM; //返回数字枚举类型 &#125; else //匹配运算符 &#123; switch (c) &#123; case &#x27;&amp;&#x27;: item-&gt;op = AND; return OPE; case &#x27;^&#x27;: item-&gt;op = XOR; return OPE; case &#x27;|&#x27;: item-&gt;op = OR; return OPE; case &#x27;&gt;&#x27;: item-&gt;op = MORE; return OPE; case &#x27;&lt;&#x27;: item-&gt;op = LESS; return OPE; case &#x27;+&#x27;: item-&gt;op = ADD; return OPE; case &#x27;-&#x27;: item-&gt;op = MIN; return OPE; case &#x27;*&#x27;: item-&gt;op = MUL; return OPE; case &#x27;/&#x27;: item-&gt;op = DIV; return OPE; case &#x27;%&#x27;: item-&gt;op = MOD; return OPE; case &#x27;!&#x27;: item-&gt;op = NOT; return OPE; case &#x27;(&#x27;: item-&gt;op = LEFT; return OPE; case &#x27;)&#x27;: item-&gt;op = RIGHT; return OPE; case &#x27; &#x27;: case &#x27;\\t&#x27;: case &#x27;\\n&#x27;: break; //空格直接跳 default: return OTH; //读到怪东西,直接报错 &#125; &#125; &#125; return EQU; //读到等号,也就是表达式末尾&#125;void Push_Ope(OpeType op)&#123; if (OpeTop == MAXSIZE - 1) //满栈,无法入栈 &#123; printf(&quot;operator stack is full!\\n&quot;); exit(1); &#125; Ope_Stack[++OpeTop] = op; return;&#125;void Push_Num(DataType num)&#123; if (NumTop == MAXSIZE - 1) &#123; printf(&quot;number stack is full!\\n&quot;); exit(1); &#125; Num_Stack[++NumTop] = num; return;&#125;OpeType Pop_Ope()&#123; if (OpeTop == -1) //栈空,无法弹栈 &#123; printf(&quot;Error Input!\\n&quot;); exit(1); &#125; return Ope_Stack[OpeTop--];&#125;DataType Pop_Num()&#123; if (NumTop == -1) &#123; printf(&quot;Error Input!\\n&quot;); exit(1); &#125; return Num_Stack[NumTop--];&#125;void operate(OpeType op)&#123; OpeType t; if (op == RIGHT) //如果读入右括号 &#123; while ((t = Pop_Ope()) != LEFT) //直到弹到左括号 calculate(t); //计算 &#125; else &#123; while (OpeTop != -1 &amp;&amp; prior[op] &lt;= prior[Ope_Stack[OpeTop]] &amp;&amp; Ope_Stack[OpeTop] != LEFT) //弹栈计算直到,栈为空 或 栈顶优先级小于读入优先级 或 栈顶为左括号. 能够压栈后再压栈 calculate(Pop_Ope()); Push_Ope(op); &#125;&#125;void calculate(OpeType op) //弹栈两数字,按照运算顺序计算,计算完成后把结果压栈&#123; DataType temp; //临时变量储存栈顶元素,防止弹栈顺序问题导致计算先后出错 switch (op) &#123; case AND: Push_Num((int)Pop_Num() &amp; (int)Pop_Num()); break; case XOR: Push_Num((int)Pop_Num() ^ (int)Pop_Num()); break; case OR: Push_Num((int)Pop_Num() | (int)Pop_Num()); break; case MORE: temp = Pop_Num(); Push_Num(Pop_Num() &gt; temp); break; case LESS: temp = Pop_Num(); Push_Num(Pop_Num() &lt; temp); break; case ADD: Push_Num(Pop_Num() + Pop_Num()); break; case MIN: temp = Pop_Num(); Push_Num(Pop_Num() - temp); break; case MUL: Push_Num(Pop_Num() * Pop_Num()); break; case DIV: temp = Pop_Num(); Push_Num(Pop_Num() / temp); break; case MOD: temp = Pop_Num(); Push_Num((int)Pop_Num() % (int)temp); break; case NOT: Push_Num(!(int)Pop_Num()); break; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://peperrcat.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://peperrcat.github.io/tags/%E6%A0%88/"}]},{"title":"栈与卡特兰数","slug":"栈与卡特兰数","date":"2022-04-14T09:23:28.000Z","updated":"2022-07-16T15:24:40.438Z","comments":true,"path":"2022/04/14/栈与卡特兰数/","link":"","permalink":"https://peperrcat.github.io/2022/04/14/%E6%A0%88%E4%B8%8E%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/","excerpt":"","text":"摘要：本文是基于栈的后入先出性质研究的出栈顺序数目的问题，具有一定的拓展性，因此，笔者于此小研究一下，希望对以后的学习有所帮助。 [TOC] 栈与卡特兰数引入众所周知，栈是一种较为重要的数据结构，它具有先入后出的FILO性质（即First In Last Out）。正是由于这种特殊的性质，当我们给定一个入栈顺序的时候，他的出栈顺序是什么样的呢，又应该有多少种呢，是否所有n个元素的任意排列都能符合出栈顺序呢？下面我们对这个问题进行简单的研究。 首先是判断出栈顺序合理性问题，这里用的是入栈出栈模拟方法： 设有一顺序栈S，n个不同的元素a1,a2,a3,…,an依次进栈，给出一个算法，判断上述元素的一个排列是否是合法的出栈序列，如果是，给出其出栈过程中所需的栈容量最小值。例如： 输入入栈序列abc，出栈序列cba，输出：3 输入入栈序列abc，出栈序列cab，输出：不合法 输入入栈序列a,b,c,d,e,f，出栈序列b,d,c,f,e,a，输出：3 对于出栈序列的目标值，先将其设为第一个出栈元素，必须让元素依次入栈直到栈顶为目标值才可以出栈，然后继续匹配下一目标值，即出栈的下一元素。若所有元素均入栈但未能成功匹配则不合法，否则匹配成功，合法，输出最大栈顶值加一。 #include &lt;stdio.h&gt;int stack[100], top = -1;int main()&#123; int outstack[100], num = 1, element, max = -1; while (~scanf(&quot;%d&quot;, &amp;element)) //输入 &#123; outstack[num++] = element; &#125; int i = 1, j = 1; while (i &lt; num) &#123; while ((top == -1 || stack[top] != outstack[i]) &amp;&amp; j &lt; num) //栈空或栈顶不为目标值则不停入栈直到栈顶为出栈顺序对应目标值，当全入栈完后也停止入栈。 &#123; stack[++top] = j++; &#125; if (max &lt; top) max = top; //更新max if (outstack[i] == stack[top]) //判断栈顶是否能够入到目标值 --top; //能则出栈 else &#123; printf(&quot;false\\n&quot;); //不能则说明该出栈顺序非法，输出false return 0; &#125; i++; //匹配出栈顺序的下一目标值 &#125; printf(&quot;true: %d\\n&quot;, max + 1); //成功完成循环输出true return 0;&#125; 其次是排列出所有可能的出栈种类。 设有一顺序栈S，n个不同的元素a1,a2,a3,…,an依次进栈，给出一个算法，求出所有合法的出栈顺序以及个数。 分析题目，每个状态对于都有下一个数入栈和栈顶出栈两种操作，因此可以使用深度优先搜索（DFS），通过递归来求解，下面是C语言实现。 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int ans, n = 0;int IsEmpty(int top) //栈空判断&#123; return top == -1;&#125;void dfs(int stack[], int top, int x, int outstack[], int num) //DFS过程&#123; if (x == n + 1) //递归边界 &#123; ans++; for (int i = 0; i &lt; num; i++) &#123; printf(&quot;%d &quot;, outstack[i]); &#125; //输出已经出栈元素 for (int i = top; i &gt;= 0; i--) &#123; printf(&quot;%d &quot;, stack[i]); &#125; //输出栈中后出栈元素 printf(&quot;\\n&quot;); return; &#125; if (!IsEmpty(top)) //栈不为空，两种情况。 &#123; int topnum = stack[top]; stack[top--] = 0; outstack[num++] = topnum; dfs(stack, top, x, outstack, num); //情况一：弹栈并递归 outstack[num--] = 0; //注意回溯，防止stack改变 stack[++top] = topnum; //回溯 stack[++top] = x; dfs(stack, top, x + 1, outstack, num); //情况二：入栈并递归 &#125; else //栈为空，入栈并递归 &#123; stack[++top] = x; dfs(stack, top, x + 1, outstack, num); &#125;&#125;int main()&#123; int stack[100] = &#123;0&#125;, top = -1, outstack[100] = &#123;0&#125;, num = 0; //outstack用来记录出栈的数，num是outstack中的数。 scanf(&quot;%d&quot;, &amp;n); dfs(stack, top, 1, outstack, num); //参数引入stack，top，oustack，num这些局部变量而不是全局变量，是为了每次递归结束后不改变原始stack，outstack中的值。 printf(&quot;%d&quot;, ans); return 0;&#125; 以上代码运行结果如下： /*n = 1*/1/*n = 2*/2/*n = 3*/5/*n = 4*/14/*n = 5*/42/*n = 6*/132/*n = 7*/429... 观察其规律从第一项开始，构成数列1，2，5，14，42，132，429…… 显然，这并不是全排列数，而且数目必然比全排列要少许多，直接分析数字之间的规律并不能找到明显的通项或者递推公式。因此还要把问题从模拟上升到本质问题解决上。 问题分析我们设出栈顺序数目构成的数列通项为 f(n) 。对于该问题，n = 1，2，3都很容易列举出来，故我们从n = 4开始分析。假设入栈顺序为a、b、c、d，最先入栈的1出栈可能存在四个位置：1、2、3、4，假设a出栈位于第一个位置则a入栈后立即出栈，后面b、c、d构成的出栈顺序种类数为 f(3) ，而a之前的出栈种类数应为 f(0)（定义f(0)= 1），由于a前后出栈是独立的，故使用乘法原理可以得到对应出栈种类数为 f(3) * f(0)。同理a在2、3、4位置同样可以得到对应出栈种类数为f(2) * f(1)、f(1) * f(2)、f(0) * f(3)，于是 f(4) = f(0) * f(3) + f(1) * f(2) + f(2) * f(1) + f(3) * f(0)，那么对于n个入栈元素，对应的出栈种类数可以同理得到：$$f(n) = \\sum_{i=0}^{n-1}f(i)f(n-i-1)\\tag{1}$$这就是对应 f(n)的一个递推公式了，而这个递推公式得出得数列被称之为卡特兰数，我们用 $Cn$ 表示。根据数学上的等价证明我们可以得到卡特兰数的通项和一些递推公式如下（时间原因这里就不证明了。其实是实力问题）：$$递推公式：C_n = \\frac{4n-2}{n+1}C_{n-1}\\tag{2}$$ $$通项公式：C_n = \\frac{1}{n+1}C^n_{2n} = C^n_{2n} - C^{n-1}_{2n}\\tag{3}$$ 通过递推or递归的代码实现如下： long long C[n];C[0] = C[1] = 1;long long Catalan_number(int n) //递推&#123; for (int i = 2; i &lt;= n; i++) &#123; C[i] = (4 * i - 2) * C[i - 1] / (i + 1); //除法放在最后防止取整丢失小数部分 &#125; return C[n];&#125;long long Catalan_number(int n) //递归&#123; int sum = 0; if (n == 0 || n ==1) //递归边界 return 1; for (int i = 0; i &lt; n; i++) &#123; sum += Catalan_number(i) * Catalan_number(n - i - 1); &#125; return sum;&#125;/*当然还可以通过组合数来计算卡特兰数，这里就不贴代码了*/ 上面代码运行的结果与用栈模拟得到的结果一致。 相关问题除了出栈顺序能构成卡特兰数数列，也有其他问题有着同样的结果 「括号匹配」 对于 n 对括号，其共有多少种合法的匹配方式？ 对于这个问题，我们有着两种解决方法，分别对应卡特兰数的两种公式。 我们任取一对括号，其他的括号组成的匹配方式分别为A，B，于是n对括号的匹配方式就是A(B)，其中AB的和种类数为n-1，A的括号数可以从0取到n-1，于是和种类数就是这种匹配方式的0到n-1的求和，也正是公式(1)&gt;对应的卡特兰数计算式。 括号的合法匹配方式为：一个左括号对应一个右括号，且左括号必须要在右括号前面出现。为了方便说明，这里将左括号记作 +1，右括号记作 -1，则一个合法序列和一个非法序列可以表示为如下形式： ()(()) -&gt; +1 -1 +1 +1 -1 -1())()( -&gt; +1 -1 -1 +1 -1 +1 我们可以证明，对于合法序列来说，其「所有前缀和」必然大于等于 0，而对于非法序列来说，其必然存在前缀和小于 0 的情况。下面我们将尝试去推导序列长度为 2n 时非法序列的数量，然后用总排列数减去非法序列数即可得到合法序列数。 对于一个非法序列，我们找到其「第一个」和小于 0 的前缀，并对其中每一位进行取反。以上面的非法序列为例，我们会得到：-1 +1 +1 +1 -1 +1，此时该序列中共有 3+1 个 +1 和 3-1 个 -1。直观上来看，第一个小于 0 的前缀和必为 -1，即 -1 比 +1 多一个，取反后则 -1 比 + 1 少一个，这样总数上看 +1 必变为 n+1 个，-1 则变为 n-1 个（因为原来二者相等）。我们可以将该结论推广为（严格的证明省略）： 对于 n 对括号的每种非法匹配序列 A，都会有一个含有 n+1 个 +1 和 n-1 个 -1 的序列 B 与其一一对应。 非法序列的数量我们可以通过排列数$C^{n+1}{2n}$来计算（等价于$C^{n-1}{2n}$），即非法序列的数量为$C^{n-1}{2n}$ 。而序列的总数量为$C^{n}{2n}$ （从 2n 个位置中选择 n 个位置放左括号，无先后顺序)，因此合法的匹配序列数量为：$$C_n = C^{n}{2n} - C^{n-1}{2n} = \\frac{C^{n}_{2n}}{n+1}$$即对应的卡特兰数公式(3)。 「单调路线」 在一个 n*n 的方格中从左下角走到右上角，不穿过对角线的单调路线有多少种？ 此问题同样可以通过前缀和来发现种类数仍然是个卡特兰数，因为向上走的数量不能多余向右走的数量，否则就会穿过对角线。 「满二叉树」 对于有 n+1 个叶子节点，其能构成多少种形状不同的满二叉树？ 需要注意的是这里的满二叉树和国内定义不同，取的是国际定义：a binary tree T is full if each node is either a leaf or possesses exactly two childnodes. 意为：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。 我们可以证明，满二叉树的分支数目为总个数减一（除了根节点每个结点都有一个指向父节点的分支），而去掉叶子结点，每个结点的度都为2，故分支数又等于总结点数减去叶子结点树后乘二，于是包含 n+1 个叶子节点的总节点个数为 2n+1，则除开根节点需要进行 2n 次扩展来形成满二叉树，如下图所示（月牙形表示叶子节点）。扩展即从父节点向左或向右添加子节点的过程，左树的结点有2k个，则右数为2(n - k)个同样用乘法原理，然后遍历整个k即可同样得到卡特兰数的递推公式。 此外，上图还可以看做 n 个节点组成不同二叉树的方案数，其中圆形表示节点，月牙形表示什么都没有，也就是n个结点任意二叉树我们可以将其补充为满二叉树（国际定义），此时节点数为2n+1。我们可以基于卡特兰数的递推关系得出该方案数即为 $C_n$。 LeetCode 96 「多边形分形」 将 n 边的凸多边形以不相交的对角线分成 n-2 个三角形，共有多少种方法？ 这个问题我们需要从递归的角度来考虑。因为凸 边形的任意一条边必定属于某一个三角形，所以我们以某一条边为基准，将这条边的两个顶点分别记作 和 ，将该凸多边形的顶点依序标记为 ，再在该凸多边形中选择任意一个不属于这两个顶点的顶点 （），来构成一个三角形，用这个三角形把该凸多边形划分为两个凸多边形，其中一个凸多边形为由 构成的凸 边形，另一个则是由 构成的凸 边形。根据乘法原理，问题的解 等价于凸 边形的划分方案数乘以凸 边形的划分方案数，遍历所有的 ，可以得到： 这也就是递推形式的卡特兰数，可以看到，对于一个凸 边形来说，其分割方法数即等价于 $C_n$。下图给出了一个正六边形的分割方案，共有 $C_4 = 14$ 种。 「买票问题」 假设一张门票 5 元，售票房没有额外的零钱。现在有 m 个人持有 5 元的纸币，n 个人持有 10 元的纸币排队买票，问有多少种排队方式，可以让每个人都买到电影票。 找零问题的本质其实就是要让持有 5 元纸币的人和持有 10 元纸币的人保持匹配，且 5 元纸币的人需要在前面，如果将持有 5 元纸币的人编号为+1，持有 10 元纸币的人编号为-1，于是应该要求前缀和保持为大于0。不难理解这就是一个卡特兰数的问题。 然而，与标准卡特兰数相比，这里的求解还有两个不同之处：首先是持有 5 元纸币的人数 m 和持有 10 元纸币的人数 n 不一定相等（注意 m必须大于等于 n ），这样我们不能直接套用卡特兰数的通项公式，而应该从原理出发重新推导，基于「总序列数减去非法序列数」的思想，合法序列数为 。此外，我们还需要考虑排队的先后顺序，因此总的排队方式数为：","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://peperrcat.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://peperrcat.github.io/tags/%E6%A0%88/"}]},{"title":"并查集","slug":"并查集","date":"2022-04-09T07:16:00.000Z","updated":"2022-07-16T15:27:52.677Z","comments":true,"path":"2022/04/09/并查集/","link":"","permalink":"https://peperrcat.github.io/2022/04/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"本文基于树的基础介绍了一种集合内元素不相交的集合的构造方法，以及集合之间合并与集合内元素查询的方法，并且基于这种方法提出路径压缩的优化方式，仅供自学使用，转载随意。 [TOC] 并查集&amp;带权并查集并查集简介现给出n个元素，分属不同的集合，我们要进行以下两种操作： 给出两个元素的关系，满足这一关系的两个元素所属集合合并。（即：x，y是亲戚，则x的亲戚也是y的亲戚，于是x，y所处两个集合可以合并成为一个新的亲戚集合。即【x所在集合】与【y所在集合】合并） 已知两个元素，判断两个元素是否存在该关系。（即判断两个元素是否在同一集合中） 经典问题：亲戚组，食物链等。 并查集原理&amp;实现”集“并查集主要通过树这一数据结构来实现。对于某一给定集合，我们任取其中的某个元素作为根结点，建立pre数组为每个元素的父结点，即使用树的双亲表示法。特别地，根节点的父节点为其本身。我们这样通过树的数据结构实现了元素之间关系构造，但是，我们并查集的目的是实现【并】与【查】的操作，那么如何进行实现呢？ “并”假设我们已知两个元素A、B存在关系，他们分属集合 α 和 β ，所以我们现在要合并集合α 和 β 。如何实现？两个集合分属两颗树，我们现在要把两棵树合成一棵树，只需要将元素A的根结点的父节点指向B元素的根节点即可，反之亦可。也就是把α 和 β 两个集合的根节点建立父子联系，我们就很轻松的实现了【并】的操作了。 ”查“根据我们建立的集合的特点，两个元素要分属一个集合，判断集合的最明显的特征就是根节点，也就是说，如果两个元素的根节点相同，那么他们自然就分属一个集合了。那我们只需要查询两个元素的根节点，判断两个根节点是否为同一个根节点就OK了。于是现在的问题来到了如何查找根节点，其实运用递归的方法也很容易实现，我们递归访问该元素的父节点，不停向上访问，最后访问到结点的父节点是本身的时候就访问到了根节点了。判断两个根节点就能实现【查】的操作了 路径压缩我们根据刚刚的讨论可以发现，并查集的操作的关键都是访问元素的根结点，而与其他元素如何联系就没有意义了，因此其时间复杂度取决于树的深度，如果一个树是斜树，或者类似斜树的形式，那么并查集的时间优化就几乎没有了。我们在并查集的时候于是我们寻找进行优化方式，最好能对树的深度进行缩短，尽量形成下图的形式，使得树的深度变成2，这样并查集的时间复杂度就会陡然下降。因此这里提出路径压缩的方法来优化树的结构。 路径压缩：我们在向上访问父节点时候，只需把经过的每个节的父结点都改成根节点，就能让树的形状尽量接近上图的形状。这种路径压缩可以大大优化树的结构，使得树的深度更小，使得时间复杂度在完全体情况下在O(1)时间复杂度就能找到根节点。并查集效率极度提高。 代码实现用数组链表构造的树都可以实现并查集操作，这里我们都使用链表的形式实现（注意指针的使用）。 typedef struct Node&#123; int val; struct Node *father;&#125; element;element *find(element *node) //递归实现根节点查询函数&#123; if (node-&gt;father != node) //递归边界 &#123; element *root = find(node-&gt;father); node-&gt;father = root; //路径压缩，路过结点的父节点都指向根结点。 return node-&gt;father; &#125; return node;&#125;void unionset(element *node_1, element *node_2) //并函数，这里把前一个的父节点设为后一个的根节点&#123; element *root = find(node_2); node_1-&gt;father = root; return;&#125;void create(element *node, int value) //创建集合函数&#123; node-&gt;val = value; node-&gt;father = node; //根节点的父节点为本身&#125; 至此，并查集的实现就成功完成了，当然，并查集有时候并不是单纯的亲戚的亲戚是亲戚的关系，而可能存在关系权重的问题了，这个时候就需要使用加权的并查集了。 带权并查集“权”首先要弄明白的是，何为【权】。权，即为两个元素之间关系的一个度量值，一般已知两个元素关系的权值，和其中一个元素与另一个非这两个元素的关系权值，则可以求出这两个元素中的另一个与非这两个元素的关系权值，且满足向量关系。如下图：已知权值r1、r2，则通过向量法可以求出r3=r2+r1（可能要进行模运算），通常，这个向量一般是由子结点指向父节点。所以，在并查集带权的情况下，我们在find（路径压缩）和union时就需要做权重的转移。如，把C路径压缩至A则需要将权值从r2变为r3。这是路径压缩的权值转换方式。特别的，在进行find路径压缩时，由于父节点变为根节点，容易失去原来父节点权重，因此需要记录下父节点权重。 同时，合并集合也需要进行权值转换，这涉及根结点之间的权值转换。经过find的路径压缩，对于元素的根节点与该元素必然是直接相连的，因此权值转换就变成了下图形式。已知r1，r2和r3，现在要把A合并到C集合中，根据向量法，r4=r2+r3-r1，于是A-&gt;C的权值就求出了。 代码实现typedef struct Node&#123; int val; int weight; struct Node *father;&#125; element;element *find(element *node) //递归实现根节点查询函数&#123; if (node-&gt;father != node) //递归边界 &#123; element *root = find(node-&gt;father); int weight0 = node-&gt;father-&gt;weight; //这里要注意记录父节点 node-&gt;father = root; //路径压缩，路过结点的父节点都指向根结点。 node-&gt;weight += weight0; //权重转移 // node-&gt;weight %= MOD; return node-&gt;father; &#125; return node;&#125;void union_set(element *node_1, element *node_2, int k) //并函数，这里把前一个的父节点设为后一个的根节点，前一个对后一个的权是k&#123; element *root1 = find(node_1), *root2 = find(node_2); root1-&gt;weight = k + node_2-&gt;weight - node_1-&gt;weight; //向量和计算root1对root2的权值 //root1-&gt;weight %= MOD; node_1-&gt;father = root; return;&#125;void create(element *node, int value) //创建集合函数&#123; node-&gt;val = value; node-&gt;father = node; //根节点的父节点为本身&#125; 至此，带权并查集的实现也就结束了。 下面介绍一道经典带权并查集的例题： 例题： [NOI2001] 食物链题目描述动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。 现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这 N 个动物所构成的食物链关系进行描述： 第一种说法是 1 X Y，表示 X 和 Y 是同类。 第二种说法是2 X Y，表示 X 吃 Y 。 此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话 当前的话中 X 或 Y 比 N 大，就是假话 当前的话表示 X 吃 X，就是假话 你的任务是根据给定的 N 和 K 句话，输出假话的总数。 输入格式第一行两个整数，N，K，表示有 N 个动物，K 句话。 第二行开始每行一句话（按照题目要求，见样例） 输出格式一行，一个整数，表示假话的总数。 输入输出样例输入100 71 101 12 1 22 2 32 3 31 1 32 3 11 5 5 输出3 说明/提示1 ≤ N ≤ 5 ∗ 10^4 1 ≤ K ≤ 10^5 首先分析思路：食物链构造正好满足向量关系，但是要取模，因此我们很容易想到可以用带权并查集来实现。 权重： 0：同类 1：捕食关系 2：被捕食关系 我们把向量置为父节点指向子结点，然后简单套模板即可。 AC代码如下：（太晚了注释以后有时间写吧0.0，这里用数组实现的） #include &lt;stdio.h&gt;int pre[50005], value[50005] = &#123;0&#125;;int n, k, x, y, op, lie = 0;int find(int x)&#123; if (x != pre[x]) &#123; int root = find(pre[x]); int val = value[pre[x]]; //这里要注意find路径压缩后，如果先把pre置为root会失去原pre的权值，因此要记录下来，笔者就是这里de了一晚上bug.... pre[x] = root; value[x] = (value[x] + val) % 3; return pre[x]; &#125; return x;&#125;void Union(int x, int y, int n)&#123; int rootx = find(x), rooty = find(y); pre[rooty] = rootx; value[rooty] = (3 - value[y] + value[x] + n) % 3;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) pre[i] = i; for (int i = 1; i &lt;= k; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;op, &amp;x, &amp;y); if (x &gt; n || y &gt; n) &#123; lie++; continue; &#125; if (op == 2 &amp;&amp; x == y) &#123; lie++; continue; &#125; if (op == 1) &#123; int rootx = find(x), rooty = find(y); if (rootx != rooty) &#123; Union(x, y, 0); &#125; else if (value[x] != value[y]) &#123; lie++; continue; &#125; &#125; if (op == 2) &#123; int rootx = find(x), rooty = find(y); if (rootx != rooty) &#123; Union(x, y, 1); &#125; else if ((value[y] - value[x] + 3) % 3 != 1) &#123; lie++; &#125; &#125; &#125; printf(&quot;%d&quot;, lie); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://peperrcat.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树","slug":"树","permalink":"https://peperrcat.github.io/tags/%E6%A0%91/"}]},{"title":"KMP","slug":"KMP","date":"2022-04-06T04:55:47.000Z","updated":"2022-04-21T16:14:58.148Z","comments":true,"path":"2022/04/06/KMP/","link":"","permalink":"https://peperrcat.github.io/2022/04/06/KMP/","excerpt":"","text":"本文是KMP算法的简单阐述与C语言实现，仅供自学使用，蒟蒻瑟瑟发抖。 [TOC] KMP简述KMP算法，即Knuth-Morris-Pratt算法，是实现字符串匹配问题的一种较为高效的算法，相比于传统的朴素模式字符串查找算法，即Brute-Force算法，它的优势在于能够显著的降低时间复杂度。即，将O(m*n)复杂度降为O(m+n)。在介绍KMP算法前，我们先简单介绍一下BF算法的原理。 BF算法（朴素字符串查找）串的简单模式匹配算法Brute-Force（布鲁特-福斯，又称朴素的模式匹配算法）算法：将主串S的第一个字符和模式串T的第1个字符比较 若相等，继续逐个比较后续字符；若不等，从主串S的下一字符起，重新与T第一个字符比较。直到主串S的一个连续子串字符序列与模式T相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。否则，匹配失败，返回值 –1。其代码通过双指针原理实现也相对比较简单。 int indexBFmatch(char* Str, char* SubStr)&#123; int i, j; int lens = strlen(Str), sublens = strlen(SubStr); for (i = 0; i &lt; lens - sublens + 1; i++) //for (i = 0; *(Str + i) != &#x27;\\0&#x27;; i++) &#123; if (*(Str + i) == *SubStr) for (j = 0; j &lt; sublens &amp;&amp; *(SubStr + j) == *(Str + i + j); j++) if (j == sublens) return i; /*for (j = 0; *(SubStr + j) != &#x27;\\0&#x27; &amp;&amp; *(SubStr + j) == *(Str + i + j); j++); if (*(SubStr + j) == &#x27;\\0&#x27;) return i;*/ &#125; return -1; &#125;//没有处理大小写无关的问题，如要处理，只需加一个大小写无关比较函数即可。 其缺点也很明显，存在两个循环，时间复杂度是O(m*n)，其本质原因是：当前匹配在找到不匹配的字符（失配）后，要将源串中下一次匹配开始位置移动一个位置（即要回溯），而未利用当前已取得匹配的信息，而导致算法时间复杂度增大，如下图，匹配过一次获取的信息可以帮助我们从①直通⑥从而省去不必要的步骤，极大减少时间复杂度。这也就是KMP算法的核心思想之一。 KMP算法原理&amp;&amp;核心思想源串称为主串，定义为S，当前匹配位置为 i ；目标串称为子串，也称模式串，定义为T，当前匹配位置为j。当前在S[i]和T[j] 失配，进行下一次匹配时：保证主串当前位置i不减小（不动或增1），即不回溯。不重置为上次匹配开始位置的下一位置；子串（即模式串）当前位置j视情况回溯至起始串位置（0），或子串中某一位置k。其中 0 ≤ k &lt; j 。那么，现在问题就出现了，如何确定 j 回溯的位置 k 呢？ BBC ABCDAB ABCDABCDABDE 这两个字符串分别在D和‘ ’的位置失配了，而我们怎么用获取的信息只将 j 回溯呢？ ABCDABD 其实，这就涉及到前缀串和后缀串的问题了，如果主串在 i 以前的后缀串与子串在 j 以前的前缀串匹 配了，那是不是就可以把 j 回溯到匹配的前缀串的后一个位置。而我们知道，子串在 i 以前和主串也是匹配的，那是不是可以把子串在 j 以前的前缀串和后缀串进行匹配如果匹配上了就回溯 j 到相应位置。这个问题现在就转化为了求子串在某个位置前的前后缀匹配问题，因此我们可以构造一个next数组，用来记录子串第 j 个位置前的最大前缀串和最大后缀串匹配的位置。如子串ABCDABD，其next数组对应为{-1,0,0,0,0,1,2,0}，这里我们看 j = 6 的情况，即ABCDAB的前后缀串匹配，显然AB能与AB匹配，而且这两个分别为重合长度最长的前后缀串了，因此next[6] = 2。即将 j 回溯到2的位置也就是C的位置，然后继续与主串匹配。这里我们要注意next[0]，如果 j = 0时候失配，那我们直接将j++，i++继续匹配，这时候j = next[j]后再加一需要回到0的位置，因此，我们将next[0]置为-1。令k = next[ j ]（函数next用子串当前位置j来计算下次开始匹配位置k，k 与j 显然具有函数关系），则注意：（1）k值仅取决于子串本身而与待匹配的主串无关。（2）k值为子串从头向后及从j向前（不含j）的两个串的最大相同部分的长度。（3）这里的两部分子串可以有部分重叠的字符，**但不可以全部重叠，即k最大为 j -1 **。由于next数组与主串无关，则现在的问题就转化为了如何根据子串快速求next数组。 next数组的本质是字符串首尾的自匹配问题，因此同样可以用KMP算法的原理，因此，我们从中可以嗅到一些递推的味道。例如串ABCDABD我们已知的是next[0] = -1，我们把i置为next的递进下标，从0开始，j置为前缀串的匹配下标，从-1开始。当i没到子串结尾时进行递推循环，如果j为-1（起始位置的特殊判定以及上一个位置甚至连首字符串都不匹配）或者第j位置的字符和第i个位置的字符匹配了，就将i++，j++（下标递进）后next[j]置为i（即回溯位置），如果没有匹配就将j回溯至next[j]（失配则回溯的思想）然后继续匹配，继续循环。至此结束循环得到nexy数组，其代码实现如下： void get_next(char SubStr[], int next[])&#123; int i=0, j=-1; next[0] = -1; while(SubStr[i]!=‘\\0’)&#123; if(j==-1 || SubStr[i]==SubStr[j])&#123; //i是模式串递进的失配位置 i++; j++; next[i]=j; //i也是next的递进下标 &#125; else j = next[j]; //若字符不同，则j值回溯到上一个值 &#125; &#125; 代码实现经过前面的原理分析，代码实际上以及呼之欲出了，这里直接给出KMP算法的C语言实现。 int KMPindex(char str[], char substr[])&#123; int i = 0, j = 0, *next; next = (int*)malloc(sizeof(int) * strlen(substr) + 1); //构造next数组 get_next(substr, next); //获取next数组 while (str[i] != &#x27;\\0&#x27; &amp;&amp; substr[j] != &#x27;\\0&#x27;) &#123; if (str[i] == substr[j]) //匹配成功继续匹配 &#123; i++; j++; &#125; else //匹配失败，回溯j后，重新匹配（若j = 0则不回溯（next[0] = -1）） j = 0 ? i++ : j = next[j]; &#125; free(next); //注意防内存泄漏 if (substr[j] == &#x27;\\0&#x27;) return i - j; //返回index注意相比开头位置i多向后移了j位 else return -1;&#125; 至此KMP算法就完全结束了，其只运用了一个while循环，用不回溯i指针的方法将时间复杂度成功缩短到了O(m+n)，除此之外值得一提的是next数组的计算实际上是个时间复杂度O(1)的过程，这也是KMP算法的核心。","categories":[{"name":"算法","slug":"算法","permalink":"https://peperrcat.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串匹配","slug":"字符串匹配","permalink":"https://peperrcat.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"}]},{"title":"hellow","slug":"hellow","date":"2022-04-05T13:17:50.000Z","updated":"2022-04-06T07:50:29.036Z","comments":true,"path":"2022/04/05/hellow/","link":"","permalink":"https://peperrcat.github.io/2022/04/05/hellow/","excerpt":"","text":"Hello World!","categories":[{"name":"NEW","slug":"NEW","permalink":"https://peperrcat.github.io/categories/NEW/"}],"tags":[{"name":"begining","slug":"begining","permalink":"https://peperrcat.github.io/tags/begining/"}]},{"title":"树与二叉树","slug":"树与二叉树","date":"2022-04-02T16:00:00.000Z","updated":"2022-04-21T16:14:47.841Z","comments":true,"path":"2022/04/03/树与二叉树/","link":"","permalink":"https://peperrcat.github.io/2022/04/03/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"本文是有关树的算法和结构的讨论，仅为自学的小小笔记，看看就好。 [TOC] 树与二叉树1.树的概念​ 树（Tree）是n（n≥0）个结点的有限集。n=0时被称为空树。在任意一颗空树中： 有且仅有一个特定的节点被称为根节点（root） 当$n&gt;1$时，其余节点可以分为m（m&gt;0）个互相不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，称之为根的子树（Subtree）。如图左侧即为树的一种；而右侧由于子树存在相交不为空情况则不为树。 graph TB;A(A)--&gt;B(B)A--&gt;C(C)B--&gt;D(D)B--&gt;E(E)B--&gt;F(f)C--&gt;G(G)a(A)--&gt;b(B)a--&gt;c(C)b--&gt;d(D)b--&gt;e(E)b--&gt;f(f)c--&gt;g(G)f--&gt;g 由于定义本身具有==递归==的思想，因此树很多时候都能用递归的思想去解决实际问题。 树的表示双亲表示法 data|parentgraph TB;A(A)--&gt;B(B)A--&gt;C(C)B--&gt;D(D)B--&gt;E(E)B--&gt;F(f)C--&gt;G(G) 编号 data parent 0 A ==-1== 1 B 0 2 C 0 3 D 1 4 E 1 5 F 1 6 G 2 双亲表示法在已知子节点向上寻根节点的时间效率较高，但已知根节点去寻子节点的复杂度较高。 孩子表示法 data|child1|childe2|….. （较为常用）存在可以存在许多孩子指针域。 struct TreeNode&#123; size_t val; struct TreeNode* child1; struct TreeNode* child3; struct TreeNode* child2; ...&#125;; 但是这种表示的缺点是构造树的时候可能有很多指针域并没有用上而造成空间上的浪费。 优化方法是：在每一个结点的数据域中增加一个变量$degreee$用来记录此节点的孩子指针域的个数 struct TreeNode&#123; size_t val; int degree; struct TreeNode* child1; struct TreeNode* child3; struct TreeNode* child2; ...&#125;; 当然还可以用哈希表（散列表）的形式储存树。即用顺序表将每个结点储起来，用单链表的形式将每个结点的子结点链接起来，当我们遍历树的时候就可以通过遍历顺序表形式来遍历所有子结点。 此种表示形式要寻找某个特定结点的子节点的时候非常容易定位。但是与双亲表示法相反，此种表示法在寻找双亲节点时需要遍历整个树。 孩子兄弟表示法 data|child|rightsibling与孩子表示法相似，此种表示法只是多了一个指针域指向此结点右边的兄弟结点，便于寻找兄弟结点。 2 .二叉树的概念二叉树（Binary Tree）是n(n&gt;0)个结点的有限集合，该集合或者为空集（称为空二叉树）。或者由一个根节点和两课互不相交的、分别称为根节点的左子树和右子树的二叉树构成。与树类似，二叉树相当于结点的孩子域限定为了两个（degree=2）。（递归） C语言种二叉树的结构体定义如下 struct TreeNode&#123; size_t val; struct TreeNode* left; struct TreeNode* right; &#125;; 二叉树的形式（特殊二叉树）斜树即所有的结点都沿一个方向延申（所有结点只有一个子结点且斜的方向一致），类似于链表，是线性链接的。 分为左斜树和右斜树。 满二叉树如果一颗二叉树中，所有的结点都有左子树和右子树，且所有的叶子结点都在同一层上。满二叉树一定是所有相同深度二叉树的节点最多，叶子结点最多的二叉树。 完全二叉树如果按层的顺序给满二叉树编号，完全二叉树的编号和满二叉树的编号在叶子结点未编号完之前一摸一样。由于此种特性。我们可以用数组来表示完全二叉树。 完全二叉树的数组表示：| a | b | c | d | e | f || —- | —- | —- | —- | —- | —- || 0 | 1 | 2 | 3 | 4 | 5 | 由此表示我们可以得到推论： 对于位置为$k$的结点，左子结点=2k+1，右子结点=2k+2。 最后一个非叶结点的位置为(N/2)-1，N为数组长度。 通过这些推论，我们可以通过数组表示完全二叉树且很轻松的找到一个节点的子结点，当然父母结点也可以通过倒推的方式寻找。 3. 二叉树的遍历及其代码实现树的遍历即以某种顺序对树中所有结点的数据域进行某种操作（如打印等）。其按顺序划分大致可以分为前序遍历、中序遍历、后序遍历三种情况。下面将分别介绍这三种遍历方式。 1. 中序遍历(LDR)中序遍历是从根结点开始对每一个结点按照左结点，本结点，右结点的顺序进行遍历的。如上图树的遍历方式就是： graph LR;3--&gt;1--&gt;4--&gt;0--&gt;5--&gt;2 其代码实现分为两种方式： 递归法 构造一个递归的函数，函数先中以递归形式遍历结点的左子树，再访问本结点，最后遍历结点的右子树，C语言实现代码如下： /*struct TreeNode&#123; int val; struct TreeNode *left, *right;&#125;*///树结点的定义void InorderTraversal(TreeNode* root) //中序遍历函数&#123; InorderTraversal(root-&gt;left); //遍历左子树 printf(&quot;%d&quot;, root-&gt;val); //打印本节点的值 InorderTraversal(root-&gt;right); //遍历右子树 return;&#125; 递归方式的实现比较简单，利用递归实现的时间复杂度是O(n)，空间复杂度也是O(n)。 循环迭代法 此种方法是用栈这种数据结构实现的，利用的是栈的后入先出原理($LIFO$)，我们直接来看其C语言代码实现： int IsEmpty(struct TreeNode **Stack) //判断栈空函数&#123; return *Stack == NULL ? 1 : 0; //只判断栈底元素是否为空即可&#125;void InorderTraversal(TreeNode* root)&#123; struct TreeNode *Stack[MAXN]; //定义一个栈用来获取结点 int top = 0; //栈顶 Stack[top] = NULL; //置空 struct TreeNode* temp = root; //定义一个临时变量来遍历结点 while (temp != NULL || !IsEmpty(Stack)) //栈不为空且temp不为空则持续循环 &#123; while (temp != NULL) //temp不为空指针则循环直到左叶子结点，否则将直接弹栈 &#123; Stack[top++] = temp; //temp入栈 temp = temp-&gt;left; //访问左子树 &#125; temp = Stack[--top]; Stack[top] = NULL; //弹栈并输出 printf(&quot;%d&quot;, temp-&gt;val); temp = temp-&gt;right; //访问右子树，右子树是空若栈不为空则继续弹栈，否则访问右子树 &#125; return;&#125; 这样不断的循环迭代直到所有的结点都入栈弹栈后即循环完毕中序遍历完毕。 2. 前序遍历(VLR) 递归法 由于递归法较为简单，这里直接上代码：（访问结点在前即可） void PreorderTraversal(TreeNode* root) //中序遍历函数&#123; printf(&quot;%d&quot;, root-&gt;val); //打印本节点的值 PreorderTraversal(root-&gt;left); //遍历左子树 PreorderTraversal(root-&gt;right); //遍历右子树 return;&#125; 循环迭代法 与中序遍历相同，只需简单的更换输出顺序即可。 int IsEmpty(struct TreeNode **Stack) //判断栈空函数&#123; return *Stack == NULL ? 1 : 0; //只判断栈底元素是否为空即可&#125;void PostorderTraversal(struct TreeNode *root)&#123; struct TreeNode *Stack[MAXN]; //定义一个栈用来获取结点 int top = 0; //栈顶 Stack[top] = NULL; //置空 struct TreeNode *temp = root; //定义一个临时变量来遍历结点 while (temp != NULL || !IsEmpty(Stack)) //栈不为空且temp不为空则持续循环 &#123; while (temp != NULL) //temp不为空指针则循环直到左叶子结点 &#123; printf(&quot;%d&quot;, temp-&gt;val); //先输出，后入栈 Stack[top++] = temp; //temp入栈 temp = temp-&gt;left; //访问左子树 &#125; temp = Stack[--top]; Stack[top] = NULL; //弹栈 temp = temp-&gt;right; //访问右子树，右子树是空若栈不为空则继续弹栈，否则访问右子树 &#125; return;&#125; 把输出（访问）调整到第二个循环的入栈开头即可。 3. 后序遍历(LRD) 递归法 void PostorderTraversal(TreeNode* root) //中序遍历函数&#123; PostorderTraversal(root-&gt;left); //遍历左子树 PostorderTraversal(root-&gt;right); //遍历右子树 printf(&quot;%d&quot;, root-&gt;val); //打印本节点的值 return;&#125; 循环迭代法 后续遍历的循环迭代就与前序中序不太相同了，由于是先访问左子节点和右子节点，而左节点不能直接访问到右节点，故代码需要有一定的改变，这里我们多定义一个临时变量PreAccess用来记录已经访问过的结点，防止重复访问。 int IsEmpty(struct TreeNode **Stack) //判断栈空函数&#123; return *Stack == NULL ? 1 : 0; //只判断栈底元素是否为空即可&#125;void PreorderTraversal(TreeNode* root)&#123; struct TreeNode *Stack[MAXN]; //定义一个栈用来获取结点 int top = 0; //栈顶 Stack[top] = NULL; //置空 struct TreeNode* temp = root; //定义一个临时变量来遍历结点 struct TreeNode *PreAccess = NULL; //定义一个临时变量PreAccess用来记录已经访问过右子树结点的结点 while (temp != NULL || !IsEmpty(Stack)) //栈不为空且temp不为空则持续循环 &#123; while (temp != NULL) //temp不为空指针则循环直到左叶子结点，否则将直接弹栈 &#123; Stack[top++] = temp; //temp入栈 temp = temp-&gt;left; //访问左子树 &#125; temp = Stack[top - 1]; //temp置为栈顶元素，判断右子树是否为空 if (temp-&gt;right != NULL &amp;&amp; PreAccess != temp-&gt;right) //右子树没访问过且不为空 temp = temp-&gt;right; else //否则弹栈并输出 &#123; temp = Stack[--top]; Stack[top] = NULL; printf(&quot;%d&quot;, temp-&gt;val); PreAccess = temp; //标记节点为已访问 temp = NULL; //置空，访问下一个栈顶元素 &#125; &#125; return;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://peperrcat.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树","slug":"树","permalink":"https://peperrcat.github.io/tags/%E6%A0%91/"}]}],"categories":[{"name":"作业分析与实现","slug":"作业分析与实现","permalink":"https://peperrcat.github.io/categories/%E4%BD%9C%E4%B8%9A%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E7%8E%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://peperrcat.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://peperrcat.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"NEW","slug":"NEW","permalink":"https://peperrcat.github.io/categories/NEW/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://peperrcat.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"https://peperrcat.github.io/tags/%E6%A0%88/"},{"name":"树","slug":"树","permalink":"https://peperrcat.github.io/tags/%E6%A0%91/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"https://peperrcat.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"begining","slug":"begining","permalink":"https://peperrcat.github.io/tags/begining/"}]}
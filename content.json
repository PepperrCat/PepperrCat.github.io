{"meta":{"title":"花椒猫猫的小窝","subtitle":"菜鸡勿喷 0.0 ","description":"这是一个神奇的个人博客","author":"Peper Cat","url":"https://pepperrcat.github.io","root":"/"},"pages":[{"title":"朋友","date":"2022-04-05T13:50:48.681Z","updated":"2022-04-05T13:50:48.681Z","comments":true,"path":"PY.html","permalink":"https://pepperrcat.github.io/PY.html","excerpt":"","text":"今夜我不会遇见你 今夜我遇见了世上的一切 但不会遇见你。 一棵夏季最后 火红的山楂树 象一辆高大女神的自行车 象一女孩畏惧群山 呆呆站在门口 她不会向我 跑来！ 我走过黄昏 型风吹向远处的平原 我将在暮色中抱住一棵孤独的树干 山楂树！一闪而过啊！山楂 我要在你的乳房下坐到天亮。 又小又美丽的山楂的乳房 在高大女神的自行车上 在农奴的手上 在夜晚就要熄灭 友情链接"},{"title":"关于","date":"2022-04-10T17:10:08.054Z","updated":"2022-04-10T17:10:08.054Z","comments":true,"path":"about.html","permalink":"https://pepperrcat.github.io/about.html","excerpt":"","text":"博客事件轴 2022年04月05日 - 第一次搭建博客，使用typora作为mackdown语言编辑器，借用了nexmoe佬的模板，实在是tql！ 2022年04月11日 - 写并查集de了一晚上bug，麻中麻，睡个好觉。 …… 开源nexmoe (Nexmoe) (github.com)（聚聚的github） 目前还没想好写啥，先放在这吧哈哈哈哈哈哈。"},{"title":"文章归档","date":"2022-04-06T06:37:22.337Z","updated":"2022-04-06T05:52:07.439Z","comments":true,"path":"archive.html","permalink":"https://pepperrcat.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"栈与表达式计算","slug":"栈与表达式计算","date":"2022-04-15T08:03:51.000Z","updated":"2022-04-15T08:37:21.599Z","comments":true,"path":"2022/04/15/栈与表达式计算/","link":"","permalink":"https://pepperrcat.github.io/2022/04/15/%E6%A0%88%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97/","excerpt":"","text":"栈与表达式计算表达式中缀表达式前缀与后缀表达式表达式求值的栈实现分析及代码终极代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;#define MAXSIZE 100 //栈容量typedef double DataType; //数据类型，可根据需要改变typedef enum symbol //字符枚举变量，用于getsym函数判断读入内容为数字，操作符，等号，还是其他&#123; NUM, OPE, EQU, OTH&#125; SymType;typedef enum operator //操作符枚举变量，用于入栈及根据优先级数列判断优先级&#123; AND, //与 XOR, //疑惑 OR, //或 MORE, //大于 LESS, //小于 ADD, MIN, MUL, DIV, MOD, //取模 NOT, //非 LEFT, //左括号 RIGHT //右括号&#125; OpeType;int prior[] = &#123;0, -1, -2, 1, 1, 2, 2, 3, 3, 3, 4, 5, 5&#125;; //优先级数列union sym //联合变量，用于读取操作符或数字&#123; DataType num; OpeType op;&#125;;OpeType Ope_Stack[MAXSIZE]; //符号栈int OpeTop = -1; //栈顶DataType Num_Stack[MAXSIZE]; //数组栈int NumTop = -1;SymType GetSym(union sym *item); //读取数字或运算符函数,返回值为相应的枚举类型(NUM OPE EQU OHE)void Push_Ope(OpeType op); //运算符压栈函数void Push_Num(DataType num);OpeType Pop_Ope(); //运算符压栈函数,返回值为弹栈元素枚举类型(ADD MIN MUL DIV)DataType Pop_Num();void operate(OpeType op); //操作函数,对无法压栈的字符串进行操作void calculate(OpeType op); //运算函数,对数字栈顶两元素以传入运算符进行运算int main()&#123; union sym item; //储存数字或运算符 SymType s; //判断getsym返回类型 while ((s = GetSym(&amp;item)) != EQU) //返回不为等号循环读取 &#123; if (s == NUM) //数字直接压栈 Push_Num(item.num); else if (s == OPE) //符号导入操作函数进行操作 &#123; operate(item.op); &#125; else //否则输入有问题 &#123; printf(&quot;Error Input!\\n&quot;); return 1; &#125; &#125; while (OpeTop != -1) //读取操作完成后, 把符号栈剩余符号全部弹栈计算一遍 &#123; calculate(Pop_Ope()); &#125; if (NumTop == 0) //计算完成符号栈清空,数字栈只剩一个元素,弹栈输出即可 printf(&quot;%g\\n&quot;, Pop_Num()); else //否则输入有问题 &#123; printf(&quot;Error Input!\\n&quot;); return 1; &#125;&#125;SymType GetSym(union sym *item)&#123; char c; while ((c = getchar()) != &#x27;=&#x27;) &#123; if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; for (item-&gt;num = 0; c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;; c = getchar()) //多位数字处理 &#123; item-&gt;num = item-&gt;num * 10 + c - &#x27;0&#x27;; &#125; ungetc(c, stdin); //退回缓冲区,防止读入符号丢失 return NUM; //返回数字枚举类型 &#125; else //匹配运算符 &#123; switch (c) &#123; case &#x27;&amp;&#x27;: item-&gt;op = AND; return OPE; case &#x27;^&#x27;: item-&gt;op = XOR; return OPE; case &#x27;|&#x27;: item-&gt;op = OR; return OPE; case &#x27;&gt;&#x27;: item-&gt;op = MORE; return OPE; case &#x27;&lt;&#x27;: item-&gt;op = LESS; return OPE; case &#x27;+&#x27;: item-&gt;op = ADD; return OPE; case &#x27;-&#x27;: item-&gt;op = MIN; return OPE; case &#x27;*&#x27;: item-&gt;op = MUL; return OPE; case &#x27;/&#x27;: item-&gt;op = DIV; return OPE; case &#x27;%&#x27;: item-&gt;op = MOD; return OPE; case &#x27;!&#x27;: item-&gt;op = NOT; return OPE; case &#x27;(&#x27;: item-&gt;op = LEFT; return OPE; case &#x27;)&#x27;: item-&gt;op = RIGHT; return OPE; case &#x27; &#x27;: case &#x27;\\t&#x27;: case &#x27;\\n&#x27;: break; //空格直接跳 default: return OTH; //读到怪东西,直接报错 &#125; &#125; &#125; return EQU; //读到等号,也就是表达式末尾&#125;void Push_Ope(OpeType op)&#123; if (OpeTop == MAXSIZE - 1) //满栈,无法入栈 &#123; printf(&quot;operator stack is full!\\n&quot;); exit(1); &#125; Ope_Stack[++OpeTop] = op; return;&#125;void Push_Num(DataType num)&#123; if (NumTop == MAXSIZE - 1) &#123; printf(&quot;number stack is full!\\n&quot;); exit(1); &#125; Num_Stack[++NumTop] = num; return;&#125;OpeType Pop_Ope()&#123; if (OpeTop == -1) //栈空,无法弹栈 &#123; printf(&quot;Error Input!\\n&quot;); exit(1); &#125; return Ope_Stack[OpeTop--];&#125;DataType Pop_Num()&#123; if (NumTop == -1) &#123; printf(&quot;Error Input!\\n&quot;); exit(1); &#125; return Num_Stack[NumTop--];&#125;void operate(OpeType op)&#123; OpeType t; if (op == RIGHT) //如果读入右括号 &#123; while ((t = Pop_Ope()) != LEFT) //直到弹到左括号 calculate(t); //计算 &#125; else &#123; while (OpeTop != -1 &amp;&amp; prior[op] &lt;= prior[Ope_Stack[OpeTop]] &amp;&amp; Ope_Stack[OpeTop] != LEFT) //弹栈计算直到,栈为空 或 栈顶优先级小于读入优先级 或 栈顶为左括号. 能够压栈后再压栈 calculate(Pop_Ope()); Push_Ope(op); &#125;&#125;void calculate(OpeType op) //弹栈两数字,按照运算顺序计算,计算完成后把结果压栈&#123; DataType temp; //临时变量储存栈顶元素,防止弹栈顺序问题导致计算先后出错 switch (op) &#123; case AND: Push_Num((int)Pop_Num() &amp; (int)Pop_Num()); break; case XOR: Push_Num((int)Pop_Num() ^ (int)Pop_Num()); break; case OR: Push_Num((int)Pop_Num() | (int)Pop_Num()); break; case MORE: temp = Pop_Num(); Push_Num(Pop_Num() &gt; temp); break; case LESS: temp = Pop_Num(); Push_Num(Pop_Num() &lt; temp); break; case ADD: Push_Num(Pop_Num() + Pop_Num()); break; case MIN: temp = Pop_Num(); Push_Num(Pop_Num() - temp); break; case MUL: Push_Num(Pop_Num() * Pop_Num()); break; case DIV: temp = Pop_Num(); Push_Num(Pop_Num() / temp); break; case MOD: temp = Pop_Num(); Push_Num((int)Pop_Num() % (int)temp); break; case NOT: Push_Num(!(int)Pop_Num()); break; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://pepperrcat.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://pepperrcat.github.io/tags/%E6%A0%88/"}]},{"title":"栈与卡特兰数","slug":"栈与卡特兰数","date":"2022-04-14T09:23:28.000Z","updated":"2022-04-14T09:42:10.944Z","comments":true,"path":"2022/04/14/栈与卡特兰数/","link":"","permalink":"https://pepperrcat.github.io/2022/04/14/%E6%A0%88%E4%B8%8E%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/","excerpt":"","text":"栈与卡特兰数引入设有一顺序栈S，n个元素 依次进栈，问这n个元素的任意排列都可以对应某一个可能的出栈顺序吗？如果不一定找到，那么不同出栈顺序又有多少个呢？于是我们得到了下面这个问题： 设有一顺序栈S，n个不同的元素a1,a2,a3,…,an依次进栈，给出一个算法，求出所有合法的出栈顺序以及个数。 分析题目，每个状态对于都有下一个数入栈和栈顶出栈两种操作，因此可以使用DFS通过递归来求解，下面是C语言实现。 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int ans, n = 0;int IsEmpty(int top) //栈空判断&#123; return top == -1;&#125;void dfs(int stack[], int top, int x, int outstack[], int num) //DFS过程&#123; if (x == n + 1) //递归边界 &#123; ans++; for (int i = 0; i &lt; num; i++) &#123; printf(&quot;%d &quot;, outstack[i]); &#125; //输出出栈元素 for (int i = top; i &gt;= 0; i--) &#123; printf(&quot;%d &quot;, stack[i]); &#125; //输出栈中元素 printf(&quot;\\n&quot;); return; &#125; if (!IsEmpty(top)) //栈不为空，两种情况。 &#123; int topnum = stack[top]; stack[top--] = 0; outstack[num++] = topnum; dfs(stack, top, x, outstack, num); //情况一：弹栈并递归 outstack[num--] = 0; //注意回溯，防止stack改变 stack[++top] = topnum; //回溯 stack[++top] = x; dfs(stack, top, x + 1, outstack, num); //情况二：入栈并递归 &#125; else //栈为空，入栈并递归 &#123; stack[++top] = x; dfs(stack, top, x + 1, outstack, num); &#125;&#125;int main()&#123; int stack[100] = &#123;0&#125;, top = -1, outstack[100] = &#123;0&#125;, num = 0; //outstack用来记录出栈的数，num是outstack中的数。 scanf(&quot;%d&quot;, &amp;n); dfs(stack, top, 1, outstack, num); //参数引入stack，top，oustack，num这些局部变量，是为了每次递归结束后不改变原始stack，outstack中的值。 printf(&quot;%d&quot;, ans); return 0;&#125; 设有一顺序栈S，n个不同的元素a1,a2,a3,…,an依次进栈，给出一个算法，判断上述元素的一个排列是否是合法的出栈序列，如果是，给出其出栈过程中所需的栈容量最小值。例如： 输入入栈序列abc，出栈序列cba，输出：3 输入入栈序列abc，出栈序列cab，输出：不合法 输入入栈序列a,b,c,d,e,f，出栈序列b,d,c,f,e,a，输出：3","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://pepperrcat.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://pepperrcat.github.io/tags/%E6%A0%88/"}]},{"title":"并查集","slug":"并查集","date":"2022-04-09T07:16:00.000Z","updated":"2022-04-10T17:06:55.017Z","comments":true,"path":"2022/04/09/并查集/","link":"","permalink":"https://pepperrcat.github.io/2022/04/09/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"本文基于树的基础介绍了一种集合内元素不相交的集合的构造方法，以及集合之间合并与集合内元素查询的方法，并且基于这种方法提出路径压缩的优化方式，仅供自学使用，转载随意。 并查集&amp;带权并查集并查集简介现给出n个元素，分属不同的集合，我们要进行以下两种操作： 给出两个元素的关系，满足这一关系的两个元素所属集合合并。（即：x，y是亲戚，则x的亲戚也是y的亲戚，于是x，y所处两个集合可以合并成为一个新的亲戚集合。即【x所在集合】与【y所在集合】合并） 已知两个元素，判断两个元素是否存在该关系。（即判断两个元素是否在同一集合中） 经典问题：亲戚组，食物链等。 并查集原理&amp;实现”集“并查集主要通过树这一数据结构来实现。对于某一给定集合，我们任取其中的某个元素作为根结点，建立pre数组为每个元素的父结点，即使用树的双亲表示法。特别地，根节点的父节点为其本身。我们这样通过树的数据结构实现了元素之间关系构造，但是，我们并查集的目的是实现【并】与【查】的操作，那么如何进行实现呢？ “并”假设我们已知两个元素A、B存在关系，他们分属集合 α 和 β ，所以我们现在要合并集合α 和 β 。如何实现？两个集合分属两颗树，我们现在要把两棵树合成一棵树，只需要将元素A的根结点的父节点指向B元素的根节点即可，反之亦可。也就是把α 和 β 两个集合的根节点建立父子联系，我们就很轻松的实现了【并】的操作了。 ”查“根据我们建立的集合的特点，两个元素要分属一个集合，判断集合的最明显的特征就是根节点，也就是说，如果两个元素的根节点相同，那么他们自然就分属一个集合了。那我们只需要查询两个元素的根节点，判断两个根节点是否为同一个根节点就OK了。于是现在的问题来到了如何查找根节点，其实运用递归的方法也很容易实现，我们递归访问该元素的父节点，不停向上访问，最后访问到结点的父节点是本身的时候就访问到了根节点了。判断两个根节点就能实现【查】的操作了 路径压缩我们根据刚刚的讨论可以发现，并查集的操作的关键都是访问元素的根结点，而与其他元素如何联系就没有意义了，因此其时间复杂度取决于树的深度，如果一个树是斜树，或者类似斜树的形式，那么并查集的时间优化就几乎没有了。我们在并查集的时候于是我们寻找进行优化方式，最好能对树的深度进行缩短，尽量形成下图的形式，使得树的深度变成2，这样并查集的时间复杂度就会陡然下降。因此这里提出路径压缩的方法来优化树的结构。 路径压缩：我们在向上访问父节点时候，只需把经过的每个节的父结点都改成根节点，就能让树的形状尽量接近上图的形状。这种路径压缩可以大大优化树的结构，使得树的深度更小，使得时间复杂度在完全体情况下在O(1)时间复杂度就能找到根节点。并查集效率极度提高。 代码实现用数组链表构造的树都可以实现并查集操作，这里我们都使用链表的形式实现（注意指针的使用）。 typedef struct Node&#123; int val; struct Node *father;&#125; element;element *find(element *node) //递归实现根节点查询函数&#123; if (node-&gt;father != node) //递归边界 &#123; element *root = find(node-&gt;father); node-&gt;father = root; //路径压缩，路过结点的父节点都指向根结点。 return node-&gt;father; &#125; return node;&#125;void unionset(element *node_1, element *node_2) //并函数，这里把前一个的父节点设为后一个的根节点&#123; element *root = find(node_2); node_1-&gt;father = root; return;&#125;void create(element *node, int value) //创建集合函数&#123; node-&gt;val = value; node-&gt;father = node; //根节点的父节点为本身&#125; 至此，并查集的实现就成功完成了，当然，并查集有时候并不是单纯的亲戚的亲戚是亲戚的关系，而可能存在关系权重的问题了，这个时候就需要使用加权的并查集了。 带权并查集“权”首先要弄明白的是，何为【权】。权，即为两个元素之间关系的一个度量值，一般已知两个元素关系的权值，和其中一个元素与另一个非这两个元素的关系权值，则可以求出这两个元素中的另一个与非这两个元素的关系权值，且满足向量关系。如下图：已知权值r1、r2，则通过向量法可以求出r3=r2+r1（可能要进行模运算），通常，这个向量一般是由子结点指向父节点。所以，在并查集带权的情况下，我们在find（路径压缩）和union时就需要做权重的转移。如，把C路径压缩至A则需要将权值从r2变为r3。这是路径压缩的权值转换方式。特别的，在进行find路径压缩时，由于父节点变为根节点，容易失去原来父节点权重，因此需要记录下父节点权重。 同时，合并集合也需要进行权值转换，这涉及根结点之间的权值转换。经过find的路径压缩，对于元素的根节点与该元素必然是直接相连的，因此权值转换就变成了下图形式。已知r1，r2和r3，现在要把A合并到C集合中，根据向量法，r4=r2+r3-r1，于是A-&gt;C的权值就求出了。 代码实现typedef struct Node&#123; int val; int weight; struct Node *father;&#125; element;element *find(element *node) //递归实现根节点查询函数&#123; if (node-&gt;father != node) //递归边界 &#123; element *root = find(node-&gt;father); int weight0 = node-&gt;father-&gt;weight; //这里要注意记录父节点 node-&gt;father = root; //路径压缩，路过结点的父节点都指向根结点。 node-&gt;weight += weight0; //权重转移 // node-&gt;weight %= MOD; return node-&gt;father; &#125; return node;&#125;void union_set(element *node_1, element *node_2, int k) //并函数，这里把前一个的父节点设为后一个的根节点，前一个对后一个的权是k&#123; element *root1 = find(node_1), *root2 = find(node_2); root1-&gt;weight = k + node_2-&gt;weight - node_1-&gt;weight; //向量和计算root1对root2的权值 //root1-&gt;weight %= MOD; node_1-&gt;father = root; return;&#125;void create(element *node, int value) //创建集合函数&#123; node-&gt;val = value; node-&gt;father = node; //根节点的父节点为本身&#125; 至此，带权并查集的实现也就结束了。 下面介绍一道经典带权并查集的例题： 例题： [NOI2001] 食物链题目描述动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。 现有 N 个动物，以 1 － N 编号。每个动物都是 A,B,C 中的一种，但是我们并不知道它到底是哪一种。 有人用两种说法对这 N 个动物所构成的食物链关系进行描述： 第一种说法是 1 X Y，表示 X 和 Y 是同类。 第二种说法是2 X Y，表示 X 吃 Y 。 此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话 当前的话中 X 或 Y 比 N 大，就是假话 当前的话表示 X 吃 X，就是假话 你的任务是根据给定的 N 和 K 句话，输出假话的总数。 输入格式第一行两个整数，N，K，表示有 N 个动物，K 句话。 第二行开始每行一句话（按照题目要求，见样例） 输出格式一行，一个整数，表示假话的总数。 输入输出样例输入100 71 101 12 1 22 2 32 3 31 1 32 3 11 5 5 输出3 说明/提示1 ≤ N ≤ 5 ∗ 10^4 1 ≤ K ≤ 10^5 首先分析思路：食物链构造正好满足向量关系，但是要取模，因此我们很容易想到可以用带权并查集来实现。 权重： 0：同类 1：捕食关系 2：被捕食关系 我们把向量置为父节点指向子结点，然后简单套模板即可。 AC代码如下：（太晚了注释以后有时间写吧0.0，这里用数组实现的） #include &lt;stdio.h&gt;int pre[50005], value[50005] = &#123;0&#125;;int n, k, x, y, op, lie = 0;int find(int x)&#123; if (x != pre[x]) &#123; int root = find(pre[x]); int val = value[pre[x]]; //这里要注意find路径压缩后，如果先把pre置为root会失去原pre的权值，因此要记录下来，笔者就是这里de了一晚上bug.... pre[x] = root; value[x] = (value[x] + val) % 3; return pre[x]; &#125; return x;&#125;void Union(int x, int y, int n)&#123; int rootx = find(x), rooty = find(y); pre[rooty] = rootx; value[rooty] = (3 - value[y] + value[x] + n) % 3;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) pre[i] = i; for (int i = 1; i &lt;= k; i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;op, &amp;x, &amp;y); if (x &gt; n || y &gt; n) &#123; lie++; continue; &#125; if (op == 2 &amp;&amp; x == y) &#123; lie++; continue; &#125; if (op == 1) &#123; int rootx = find(x), rooty = find(y); if (rootx != rooty) &#123; Union(x, y, 0); &#125; else if (value[x] != value[y]) &#123; lie++; continue; &#125; &#125; if (op == 2) &#123; int rootx = find(x), rooty = find(y); if (rootx != rooty) &#123; Union(x, y, 1); &#125; else if ((value[y] - value[x] + 3) % 3 != 1) &#123; lie++; &#125; &#125; &#125; printf(&quot;%d&quot;, lie); return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://pepperrcat.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树","slug":"树","permalink":"https://pepperrcat.github.io/tags/%E6%A0%91/"}]},{"title":"KMP","slug":"KMP","date":"2022-04-06T04:55:47.000Z","updated":"2022-04-15T08:41:08.261Z","comments":true,"path":"2022/04/06/KMP/","link":"","permalink":"https://pepperrcat.github.io/2022/04/06/KMP/","excerpt":"","text":"本文是KMP算法的简单阐述与C语言实现，仅供自学使用，蒟蒻瑟瑟发抖。 KMP简述KMP算法，即Knuth-Morris-Pratt算法，是实现字符串匹配问题的一种较为高效的算法，相比于传统的朴素模式字符串查找算法，即Brute-Force算法，它的优势在于能够显著的降低时间复杂度。即，将O(m*n)复杂度降为O(m+n)。在介绍KMP算法前，我们先简单介绍一下BF算法的原理。 BF算法（朴素字符串查找）串的简单模式匹配算法Brute-Force（布鲁特-福斯，又称朴素的模式匹配算法）算法：将主串S的第一个字符和模式串T的第1个字符比较 若相等，继续逐个比较后续字符；若不等，从主串S的下一字符起，重新与T第一个字符比较。直到主串S的一个连续子串字符序列与模式T相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。否则，匹配失败，返回值 –1。其代码通过双指针原理实现也相对比较简单。 int indexBFmatch(char* Str, char* SubStr)&#123; int i, j; int lens = strlen(Str), sublens = strlen(SubStr); for (i = 0; i &lt; lens - sublens + 1; i++) //for (i = 0; *(Str + i) != &#x27;\\0&#x27;; i++) &#123; if (*(Str + i) == *SubStr) for (j = 0; j &lt; sublens &amp;&amp; *(SubStr + j) == *(Str + i + j); j++) if (j == sublens) return i; /*for (j = 0; *(SubStr + j) != &#x27;\\0&#x27; &amp;&amp; *(SubStr + j) == *(Str + i + j); j++); if (*(SubStr + j) == &#x27;\\0&#x27;) return i;*/ &#125; return -1; &#125;//没有处理大小写无关的问题，如要处理，只需加一个大小写无关比较函数即可。 其缺点也很明显，存在两个循环，时间复杂度是O(m*n)，其本质原因是：当前匹配在找到不匹配的字符（失配）后，要将源串中下一次匹配开始位置移动一个位置（即要回溯），而未利用当前已取得匹配的信息，而导致算法时间复杂度增大，如下图，匹配过一次获取的信息可以帮助我们从①直通⑥从而省去不必要的步骤，极大减少时间复杂度。这也就是KMP算法的核心思想之一。 KMP算法原理&amp;&amp;核心思想源串称为主串，定义为S，当前匹配位置为 i ；目标串称为子串，也称模式串，定义为T，当前匹配位置为j。当前在S[i]和T[j] 失配，进行下一次匹配时：保证主串当前位置i不减小（不动或增1），即不回溯。不重置为上次匹配开始位置的下一位置；子串（即模式串）当前位置j视情况回溯至起始串位置（0），或子串中某一位置k。其中 0 ≤ k &lt; j 。那么，现在问题就出现了，如何确定 j 回溯的位置 k 呢？ BBC ABCDAB ABCDABCDABDE 这两个字符串分别在D和‘ ’的位置失配了，而我们怎么用获取的信息只将 j 回溯呢？ ABCDABD 其实，这就涉及到前缀串和后缀串的问题了，如果主串在 i 以前的后缀串与子串在 j 以前的前缀串匹 配了，那是不是就可以把 j 回溯到匹配的前缀串的后一个位置。而我们知道，子串在 i 以前和主串也是匹配的，那是不是可以把子串在 j 以前的前缀串和后缀串进行匹配如果匹配上了就回溯 j 到相应位置。这个问题现在就转化为了求子串在某个位置前的前后缀匹配问题，因此我们可以构造一个next数组，用来记录子串第 j 个位置前的最大前缀串和最大后缀串匹配的位置。如子串ABCDABD，其next数组对应为{-1,0,0,0,0,1,2,0}，这里我们看 j = 6 的情况，即ABCDAB的前后缀串匹配，显然AB能与AB匹配，而且这两个分别为重合长度最长的前后缀串了，因此next[6] = 2。即将 j 回溯到2的位置也就是C的位置，然后继续与主串匹配。这里我们要注意next[0]，如果 j = 0时候失配，那我们直接将j++，i++继续匹配，这时候j = next[j]后再加一需要回到0的位置，因此，我们将next[0]置为-1。令k = next[ j ]（函数next用子串当前位置j来计算下次开始匹配位置k，k 与j 显然具有函数关系），则注意：（1）k值仅取决于子串本身而与待匹配的主串无关。（2）k值为子串从头向后及从j向前（不含j）的两个串的最大相同部分的长度。（3）这里的两部分子串可以有部分重叠的字符，**但不可以全部重叠，即k最大为 j -1 **。由于next数组与主串无关，则现在的问题就转化为了如何根据子串快速求next数组。 next数组的本质是字符串首尾的自匹配问题，因此同样可以用KMP算法的原理，因此，我们从中可以嗅到一些递推的味道。例如串ABCDABD我们已知的是next[0] = -1，我们把i置为next的递进下标，从0开始，j置为前缀串的匹配下标，从-1开始。当i没到子串结尾时进行递推循环，如果j为-1（起始位置的特殊判定以及上一个位置甚至连首字符串都不匹配）或者第j位置的字符和第i个位置的字符匹配了，就将i++，j++（下标递进）后next[j]置为i（即回溯位置），如果没有匹配就将j回溯至next[j]（失配则回溯的思想）然后继续匹配，继续循环。至此结束循环得到nexy数组，其代码实现如下： void get_next(char SubStr[], int next[])&#123; int i=0, j=-1; next[0] = -1; while(SubStr[i]!=‘\\0’)&#123; if(j==-1 || SubStr[i]==SubStr[j])&#123; //i是模式串递进的失配位置 i++; j++; next[i]=j; //i也是next的递进下标 &#125; else j = next[j]; //若字符不同，则j值回溯到上一个值 &#125; &#125; 代码实现经过前面的原理分析，代码实际上以及呼之欲出了，这里直接给出KMP算法的C语言实现。 int KMPindex(char str[], char substr[])&#123; int i = 0, j = 0, *next; next = (int*)malloc(sizeof(int) * strlen(substr) + 1); //构造next数组 get_next(substr, next); //获取next数组 while (str[i] != &#x27;\\0&#x27; &amp;&amp; substr[j] != &#x27;\\0&#x27;) &#123; if (str[i] == substr[j]) //匹配成功继续匹配 &#123; i++; j++; &#125; else //匹配失败，回溯j后，重新匹配（若j = 0则不回溯（next[0] = -1）） j = 0 ? i++ : j = next[j]; &#125; free(next); //注意防内存泄漏 if (substr[j] == &#x27;\\0&#x27;) return i - j; //返回index注意相比开头位置i多向后移了j位 else return -1;&#125; 至此KMP算法就完全结束了，其只运用了一个while循环，用不回溯i指针的方法将时间复杂度成功缩短到了O(m+n)，除此之外值得一提的是next数组的计算实际上是个时间复杂度O(1)的过程，这也是KMP算法的核心。","categories":[{"name":"算法","slug":"算法","permalink":"https://pepperrcat.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串匹配","slug":"字符串匹配","permalink":"https://pepperrcat.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"}]},{"title":"hellow","slug":"hellow","date":"2022-04-05T13:17:50.000Z","updated":"2022-04-06T07:50:29.036Z","comments":true,"path":"2022/04/05/hellow/","link":"","permalink":"https://pepperrcat.github.io/2022/04/05/hellow/","excerpt":"","text":"Hello World!","categories":[{"name":"NEW","slug":"NEW","permalink":"https://pepperrcat.github.io/categories/NEW/"}],"tags":[{"name":"begining","slug":"begining","permalink":"https://pepperrcat.github.io/tags/begining/"}]},{"title":"树与二叉树","slug":"树与二叉树","date":"2022-04-02T16:00:00.000Z","updated":"2022-04-09T07:15:08.884Z","comments":true,"path":"2022/04/03/树与二叉树/","link":"","permalink":"https://pepperrcat.github.io/2022/04/03/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"本文是有关树的算法和结构的讨论，仅为自学的小小笔记，看看就好。 树与二叉树1.树的概念​ 树（Tree）是n（n≥0）个结点的有限集。n=0时被称为空树。在任意一颗空树中： 有且仅有一个特定的节点被称为根节点（root） 当$n&gt;1$时，其余节点可以分为m（m&gt;0）个互相不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，称之为根的子树（Subtree）。如图左侧即为树的一种；而右侧由于子树存在相交不为空情况则不为树。 graph TB;A(A)--&gt;B(B)A--&gt;C(C)B--&gt;D(D)B--&gt;E(E)B--&gt;F(f)C--&gt;G(G)a(A)--&gt;b(B)a--&gt;c(C)b--&gt;d(D)b--&gt;e(E)b--&gt;f(f)c--&gt;g(G)f--&gt;g 由于定义本身具有==递归==的思想，因此树很多时候都能用递归的思想去解决实际问题。 树的表示双亲表示法 data|parentgraph TB;A(A)--&gt;B(B)A--&gt;C(C)B--&gt;D(D)B--&gt;E(E)B--&gt;F(f)C--&gt;G(G) 编号 data parent 0 A ==-1== 1 B 0 2 C 0 3 D 1 4 E 1 5 F 1 6 G 2 双亲表示法在已知子节点向上寻根节点的时间效率较高，但已知根节点去寻子节点的复杂度较高。 孩子表示法 data|child1|childe2|….. （较为常用）存在可以存在许多孩子指针域。 struct TreeNode&#123; size_t val; struct TreeNode* child1; struct TreeNode* child3; struct TreeNode* child2; ...&#125;; 但是这种表示的缺点是构造树的时候可能有很多指针域并没有用上而造成空间上的浪费。 优化方法是：在每一个结点的数据域中增加一个变量$degreee$用来记录此节点的孩子指针域的个数 struct TreeNode&#123; size_t val; int degree; struct TreeNode* child1; struct TreeNode* child3; struct TreeNode* child2; ...&#125;; 当然还可以用哈希表（散列表）的形式储存树。即用顺序表将每个结点储起来，用单链表的形式将每个结点的子结点链接起来，当我们遍历树的时候就可以通过遍历顺序表形式来遍历所有子结点。 此种表示形式要寻找某个特定结点的子节点的时候非常容易定位。但是与双亲表示法相反，此种表示法在寻找双亲节点时需要遍历整个树。 孩子兄弟表示法 data|child|rightsibling与孩子表示法相似，此种表示法只是多了一个指针域指向此结点右边的兄弟结点，便于寻找兄弟结点。 2 .二叉树的概念二叉树（Binary Tree）是n(n&gt;0)个结点的有限集合，该集合或者为空集（称为空二叉树）。或者由一个根节点和两课互不相交的、分别称为根节点的左子树和右子树的二叉树构成。与树类似，二叉树相当于结点的孩子域限定为了两个（degree=2）。（递归） C语言种二叉树的结构体定义如下 struct TreeNode&#123; size_t val; struct TreeNode* left; struct TreeNode* right; &#125;; 二叉树的形式（特殊二叉树）斜树即所有的结点都沿一个方向延申（所有结点只有一个子结点且斜的方向一致），类似于链表，是线性链接的。 分为左斜树和右斜树。 满二叉树如果一颗二叉树中，所有的结点都有左子树和右子树，且所有的叶子结点都在同一层上。满二叉树一定是所有相同深度二叉树的节点最多，叶子结点最多的二叉树。 完全二叉树如果按层的顺序给满二叉树编号，完全二叉树的编号和满二叉树的编号在叶子结点未编号完之前一摸一样。由于此种特性。我们可以用数组来表示完全二叉树。 完全二叉树的数组表示：| a | b | c | d | e | f || —- | —- | —- | —- | —- | —- || 0 | 1 | 2 | 3 | 4 | 5 | 由此表示我们可以得到推论： 对于位置为$k$的结点，左子结点=2k+1，右子结点=2k+2。 最后一个非叶结点的位置为(N/2)-1，N为数组长度。 通过这些推论，我们可以通过数组表示完全二叉树且很轻松的找到一个节点的子结点，当然父母结点也可以通过倒推的方式寻找。 3. 二叉树的遍历及其代码实现树的遍历即以某种顺序对树中所有结点的数据域进行某种操作（如打印等）。其按顺序划分大致可以分为前序遍历、中序遍历、后序遍历三种情况。下面将分别介绍这三种遍历方式。 1. 中序遍历(LDR)中序遍历是从根结点开始对每一个结点按照左结点，本结点，右结点的顺序进行遍历的。如上图树的遍历方式就是： graph LR;3--&gt;1--&gt;4--&gt;0--&gt;5--&gt;2 其代码实现分为两种方式： 递归法 构造一个递归的函数，函数先中以递归形式遍历结点的左子树，再访问本结点，最后遍历结点的右子树，C语言实现代码如下： /*struct TreeNode&#123; int val; struct TreeNode *left, *right;&#125;*///树结点的定义void InorderTraversal(TreeNode* root) //中序遍历函数&#123; InorderTraversal(root-&gt;left); //遍历左子树 printf(&quot;%d&quot;, root-&gt;val); //打印本节点的值 InorderTraversal(root-&gt;right); //遍历右子树 return;&#125; 递归方式的实现比较简单，利用递归实现的时间复杂度是O(n)，空间复杂度也是O(n)。 循环迭代法 此种方法是用栈这种数据结构实现的，利用的是栈的后入先出原理($LIFO$)，我们直接来看其C语言代码实现： int IsEmpty(struct TreeNode **Stack) //判断栈空函数&#123; return *Stack == NULL ? 1 : 0; //只判断栈底元素是否为空即可&#125;void InorderTraversal(TreeNode* root)&#123; struct TreeNode *Stack[MAXN]; //定义一个栈用来获取结点 int top = 0; //栈顶 Stack[top] = NULL; //置空 struct TreeNode* temp = root; //定义一个临时变量来遍历结点 while (temp != NULL || !IsEmpty(Stack)) //栈不为空且temp不为空则持续循环 &#123; while (temp != NULL) //temp不为空指针则循环直到左叶子结点，否则将直接弹栈 &#123; Stack[top++] = temp; //temp入栈 temp = temp-&gt;left; //访问左子树 &#125; temp = Stack[--top]; Stack[top] = NULL; //弹栈并输出 printf(&quot;%d&quot;, temp-&gt;val); temp = temp-&gt;right; //访问右子树，右子树是空若栈不为空则继续弹栈，否则访问右子树 &#125; return;&#125; 这样不断的循环迭代直到所有的结点都入栈弹栈后即循环完毕中序遍历完毕。 2. 前序遍历(VLR) 递归法 由于递归法较为简单，这里直接上代码：（访问结点在前即可） void PreorderTraversal(TreeNode* root) //中序遍历函数&#123; printf(&quot;%d&quot;, root-&gt;val); //打印本节点的值 PreorderTraversal(root-&gt;left); //遍历左子树 PreorderTraversal(root-&gt;right); //遍历右子树 return;&#125; 循环迭代法 与中序遍历相同，只需简单的更换输出顺序即可。 int IsEmpty(struct TreeNode **Stack) //判断栈空函数&#123; return *Stack == NULL ? 1 : 0; //只判断栈底元素是否为空即可&#125;void PostorderTraversal(struct TreeNode *root)&#123; struct TreeNode *Stack[MAXN]; //定义一个栈用来获取结点 int top = 0; //栈顶 Stack[top] = NULL; //置空 struct TreeNode *temp = root; //定义一个临时变量来遍历结点 while (temp != NULL || !IsEmpty(Stack)) //栈不为空且temp不为空则持续循环 &#123; while (temp != NULL) //temp不为空指针则循环直到左叶子结点 &#123; printf(&quot;%d&quot;, temp-&gt;val); //先输出，后入栈 Stack[top++] = temp; //temp入栈 temp = temp-&gt;left; //访问左子树 &#125; temp = Stack[--top]; Stack[top] = NULL; //弹栈 temp = temp-&gt;right; //访问右子树，右子树是空若栈不为空则继续弹栈，否则访问右子树 &#125; return;&#125; 把输出（访问）调整到第二个循环的入栈开头即可。 3. 后序遍历(LRD) 递归法 void PostorderTraversal(TreeNode* root) //中序遍历函数&#123; PostorderTraversal(root-&gt;left); //遍历左子树 PostorderTraversal(root-&gt;right); //遍历右子树 printf(&quot;%d&quot;, root-&gt;val); //打印本节点的值 return;&#125; 循环迭代法 后续遍历的循环迭代就与前序中序不太相同了，由于是先访问左子节点和右子节点，而左节点不能直接访问到右节点，故代码需要有一定的改变，这里我们多定义一个临时变量PreAccess用来记录已经访问过的结点，防止重复访问。 int IsEmpty(struct TreeNode **Stack) //判断栈空函数&#123; return *Stack == NULL ? 1 : 0; //只判断栈底元素是否为空即可&#125;void PreorderTraversal(TreeNode* root)&#123; struct TreeNode *Stack[MAXN]; //定义一个栈用来获取结点 int top = 0; //栈顶 Stack[top] = NULL; //置空 struct TreeNode* temp = root; //定义一个临时变量来遍历结点 struct TreeNode *PreAccess = NULL; //定义一个临时变量PreAccess用来记录已经访问过右子树结点的结点 while (temp != NULL || !IsEmpty(Stack)) //栈不为空且temp不为空则持续循环 &#123; while (temp != NULL) //temp不为空指针则循环直到左叶子结点，否则将直接弹栈 &#123; Stack[top++] = temp; //temp入栈 temp = temp-&gt;left; //访问左子树 &#125; temp = Stack[top - 1]; //temp置为栈顶元素，判断右子树是否为空 if (temp-&gt;right != NULL &amp;&amp; PreAccess != temp-&gt;right) //右子树没访问过且不为空 temp = temp-&gt;right; else //否则弹栈并输出 &#123; temp = Stack[--top]; Stack[top] = NULL; printf(&quot;%d&quot;, temp-&gt;val); PreAccess = temp; //标记节点为已访问 temp = NULL; //置空，访问下一个栈顶元素 &#125; &#125; return;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://pepperrcat.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树","slug":"树","permalink":"https://pepperrcat.github.io/tags/%E6%A0%91/"}]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://pepperrcat.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://pepperrcat.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"NEW","slug":"NEW","permalink":"https://pepperrcat.github.io/categories/NEW/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://pepperrcat.github.io/tags/%E6%A0%88/"},{"name":"树","slug":"树","permalink":"https://pepperrcat.github.io/tags/%E6%A0%91/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"https://pepperrcat.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"begining","slug":"begining","permalink":"https://pepperrcat.github.io/tags/begining/"}]}
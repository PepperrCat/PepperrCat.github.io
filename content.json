{"meta":{"title":"花椒猫猫的小窝","subtitle":"菜鸡勿喷 0.0 ","description":"这是一个神奇的个人博客","author":"Peper Cat","url":"https://pepperrcat.github.io","root":"/"},"pages":[{"title":"朋友","date":"2022-04-05T13:50:48.681Z","updated":"2022-04-05T13:50:48.681Z","comments":true,"path":"PY.html","permalink":"https://pepperrcat.github.io/PY.html","excerpt":"","text":"今夜我不会遇见你 今夜我遇见了世上的一切 但不会遇见你。 一棵夏季最后 火红的山楂树 象一辆高大女神的自行车 象一女孩畏惧群山 呆呆站在门口 她不会向我 跑来！ 我走过黄昏 型风吹向远处的平原 我将在暮色中抱住一棵孤独的树干 山楂树！一闪而过啊！山楂 我要在你的乳房下坐到天亮。 又小又美丽的山楂的乳房 在高大女神的自行车上 在农奴的手上 在夜晚就要熄灭 友情链接"},{"title":"文章归档","date":"2022-04-06T06:37:22.337Z","updated":"2022-04-06T05:52:07.439Z","comments":true,"path":"archive.html","permalink":"https://pepperrcat.github.io/archive.html","excerpt":"","text":""},{"title":"关于","date":"2022-04-05T15:05:40.516Z","updated":"2022-04-05T15:05:40.516Z","comments":true,"path":"about.html","permalink":"https://pepperrcat.github.io/about.html","excerpt":"","text":"博客事件轴 2022年04月05日 - 第一次搭建博客，使用typora作为mackdown语言编辑器，借用了nexmoe佬的模板，实在是tql！ …… 开源nexmoe (Nexmoe) (github.com)（聚聚的github） 目前还没想好写啥，先放在这吧哈哈哈哈哈哈。"}],"posts":[{"title":"KMP","slug":"KMP","date":"2022-04-06T04:55:47.000Z","updated":"2022-04-07T10:27:57.310Z","comments":true,"path":"2022/04/06/KMP/","link":"","permalink":"https://pepperrcat.github.io/2022/04/06/KMP/","excerpt":"","text":"**本文是KMP算法的简单阐述与C语言实现，仅供自学使用，蒟蒻瑟瑟发抖。** KMP简述KMP算法，即Knuth-Morris-Pratt算法，是实现字符串匹配问题的一种较为高效的算法，相比于传统的朴素模式字符串查找算法，即Brute-Force算法，它的优势在于能够显著的降低时间复杂度。即，将O(m*n)复杂度降为O(m+n)。在介绍KMP算法前，我们先简单介绍一下BF算法的原理。 BF算法（朴素字符串查找）串的简单模式匹配算法Brute-Force（布鲁特-福斯，又称朴素的模式匹配算法）算法：将主串S的第一个字符和模式串T的第1个字符比较 若相等，继续逐个比较后续字符；若不等，从主串S的下一字符起，重新与T第一个字符比较。直到主串S的一个连续子串字符序列与模式T相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。否则，匹配失败，返回值 –1。其代码通过双指针原理实现也相对比较简单。 int indexBFmatch(char* Str, char* SubStr)&#123; int i, j; int lens = strlen(Str), sublens = strlen(SubStr); for (i = 0; i &lt; lens - sublens + 1; i++) //for (i = 0; *(Str + i) != &#x27;\\0&#x27;; i++) &#123; if (*(Str + i) == *SubStr) for (j = 0; j &lt; sublens &amp;&amp; *(SubStr + j) == *(Str + i + j); j++) if (j == sublens) return i; /*for (j = 0; *(SubStr + j) != &#x27;\\0&#x27; &amp;&amp; *(SubStr + j) == *(Str + i + j); j++); if (*(SubStr + j) == &#x27;\\0&#x27;) return i;*/ &#125; return -1; &#125;//没有处理大小写无关的问题，如要处理，只需加一个大小写无关比较函数即可。 其缺点也很明显，存在两个循环，时间复杂度是O(m*n)，其本质原因是：当前匹配在找到不匹配的字符（失配）后，要将源串中下一次匹配开始位置移动一个位置（即要回溯），而未利用当前已取得匹配的信息，而导致算法时间复杂度增大，如下图，匹配过一次获取的信息可以帮助我们从①直通⑥从而省去不必要的步骤，极大减少时间复杂度。这也就是KMP算法的核心思想之一。 KMP算法原理&amp;&amp;核心思想源串称为主串，定义为S，当前匹配位置为 i ；目标串称为子串，也称模式串，定义为T，当前匹配位置为j。当前在S[i]和T[j] 失配，进行下一次匹配时：保证主串当前位置i不减小（不动或增1），即不回溯。不重置为上次匹配开始位置的下一位置；子串（即模式串）当前位置j视情况回溯至起始串位置（0），或子串中某一位置k。其中 0 ≤ k &lt; j 。那么，现在问题就出现了，如何确定 j 回溯的位置 k 呢？ BBC ABCDAB ABCDABCDABDE 这两个字符串分别在D和‘ ’的位置失配了，而我们怎么用获取的信息只将 j 回溯呢？ ABCDABD 其实，这就涉及到前缀串和后缀串的问题了，如果主串在 i 以前的后缀串与子串在 j 以前的前缀串匹 配了，那是不是就可以把 j 回溯到匹配的前缀串的后一个位置。而我们知道，子串在 i 以前和主串也是匹配的，那是不是可以把子串在 j 以前的前缀串和后缀串进行匹配如果匹配上了就回溯 j 到相应位置。这个问题现在就转化为了求子串在某个位置前的前后缀匹配问题，因此我们可以构造一个next数组，用来记录子串第 j 个位置前的最大前缀串和最大后缀串匹配的位置。如子串ABCDABD，其next数组对应为{-1,0,0,0,0,1,2,0}，这里我们看 j = 6 的情况，即ABCDAB的前后缀串匹配，显然AB能与AB匹配，而且这两个分别为重合长度最长的前后缀串了，因此next[6] = 2。即将 j 回溯到2的位置也就是C的位置，然后继续与主串匹配。这里我们要注意next[0]，如果 j = 0时候失配，那我们直接将j++，i++继续匹配，这时候j = next[j]后再加一需要回到0的位置，因此，我们将next[0]置为-1。令k = next[ j ]（函数next用子串当前位置j来计算下次开始匹配位置k，k 与j 显然具有函数关系），则注意：（1）k值仅取决于子串本身而与待匹配的主串无关。（2）k值为子串从头向后及从j向前（不含j）的两个串的最大相同部分的长度。（3）这里的两部分子串可以有部分重叠的字符，**但不可以全部重叠，即k最大为 j -1 **。由于next数组与主串无关，则现在的问题就转化为了如何根据子串快速求next数组。 next数组的本质是字符串首尾的自匹配问题，因此同样可以用KMP算法的原理，因此，我们从中可以嗅到一些递推的味道。例如串ABCDABD我们已知的是next[0] = -1，我们把i置为next的递进下标，从0开始，j置为前缀串的匹配下标，从-1开始。当i没到子串结尾时进行递推循环，如果j为-1（起始位置的特殊判定以及上一个位置甚至连首字符串都不匹配）或者第j位置的字符和第i个位置的字符匹配了，就将i++，j++（下标递进）后next[j]置为i（即回溯位置），如果没有匹配就将j回溯至next[j]（失配则回溯的思想）然后继续匹配，继续循环。至此结束循环得到nexy数组，其代码实现如下： void get_next(char SubStr[], int next[])&#123; int i=0, j=-1; next[0] = -1; while(T[i]!=‘\\0’)&#123; if(j==-1 || T[i]==T[j])&#123; //i是模式串递进的失配位置 i++; j++; next[i]=j; //i也是next的递进下标 &#125; else j = next[j]; //若字符不同，则j值回溯到上一个值 &#125; &#125; 代码实现经过前面的原理分析，代码实际上以及呼之欲出了，这里直接给出KMP算法的C语言实现。 int KMPindex(char str[], char substr[])&#123; int i = 0, j = 0, *next; next = (int*)malloc(sizeof(int) * strlen(substr) + 1); //构造next数组 get_next(substr, next); //获取next数组 while (str[i] != &#x27;\\0&#x27; &amp;&amp; substr[j] != &#x27;\\0&#x27;) &#123; if (str[i] == substr[j]) //匹配成功继续匹配 &#123; i++; j++; &#125; else //匹配失败，回溯j后，重新匹配（若j = 0则不回溯（next[0] = -1）） j = 0 ? i++ : j = next[j]; &#125; free(next); //注意防内存泄漏 if (substr[j] == &#x27;\\0&#x27;) return i - j; //返回index注意相比开头位置i多向后移了j位 else return -1;&#125; 至此KMP算法就完全结束了，其只运用了一个while循环，用不回溯i指针的方法将时间复杂度成功缩短到了O(m+n)，除此之外值得一提的是next数组的计算实际上是个时间复杂度O(1)的过程，这也是KMP算法的核心。","categories":[{"name":"算法","slug":"算法","permalink":"https://pepperrcat.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串匹配","slug":"字符串匹配","permalink":"https://pepperrcat.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"}]},{"title":"并查集","slug":"并查集","date":"2022-04-05T14:09:47.000Z","updated":"2022-04-06T06:11:34.633Z","comments":true,"path":"2022/04/05/并查集/","link":"","permalink":"https://pepperrcat.github.io/2022/04/05/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"并查集","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://pepperrcat.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树","slug":"树","permalink":"https://pepperrcat.github.io/tags/%E6%A0%91/"}]},{"title":"hellow","slug":"hellow","date":"2022-04-05T13:17:50.000Z","updated":"2022-04-06T07:50:29.036Z","comments":true,"path":"2022/04/05/hellow/","link":"","permalink":"https://pepperrcat.github.io/2022/04/05/hellow/","excerpt":"","text":"Hello World!","categories":[{"name":"NEW","slug":"NEW","permalink":"https://pepperrcat.github.io/categories/NEW/"}],"tags":[{"name":"begining","slug":"begining","permalink":"https://pepperrcat.github.io/tags/begining/"}]},{"title":"树与二叉树","slug":"树与二叉树","date":"2022-04-02T16:00:00.000Z","updated":"2022-04-06T07:39:20.885Z","comments":true,"path":"2022/04/03/树与二叉树/","link":"","permalink":"https://pepperrcat.github.io/2022/04/03/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"本文是有关树的算法和结构的讨论，仅为自学的小小笔记，~~看看就好~~。 树与二叉树1.树的概念​ 树（Tree）是n（n≥0）个结点的有限集。n=0时被称为空树。在任意一颗空树中： 有且仅有一个特定的节点被称为根节点（root） 当$n&gt;1$时，其余节点可以分为m（m&gt;0）个互相不相交的有限集T1、T2、……、Tm，其中每一个集合本身又是一棵树，称之为根的子树（Subtree）。如图左侧即为树的一种；而右侧由于子树存在相交不为空情况则不为树。 graph TB;A(A)--&gt;B(B)A--&gt;C(C)B--&gt;D(D)B--&gt;E(E)B--&gt;F(f)C--&gt;G(G)a(A)--&gt;b(B)a--&gt;c(C)b--&gt;d(D)b--&gt;e(E)b--&gt;f(f)c--&gt;g(G)f--&gt;g 由于定义本身具有==递归==的思想，因此树很多时候都能用递归的思想去解决实际问题。 树的表示双亲表示法 data|parentgraph TB;A(A)--&gt;B(B)A--&gt;C(C)B--&gt;D(D)B--&gt;E(E)B--&gt;F(f)C--&gt;G(G) 编号 data parent 0 A ==-1== 1 B 0 2 C 0 3 D 1 4 E 1 5 F 1 6 G 2 双亲表示法在已知子节点向上寻根节点的时间效率较高，但已知根节点去寻子节点的复杂度较高。 孩子表示法 data|child1|childe2|….. （较为常用）存在可以存在许多孩子指针域。 struct TreeNode&#123; size_t val; struct TreeNode* child1; struct TreeNode* child3; struct TreeNode* child2; ...&#125;; 但是这种表示的缺点是构造树的时候可能有很多指针域并没有用上而造成空间上的浪费。 优化方法是：在每一个结点的数据域中增加一个变量$degreee$用来记录此节点的孩子指针域的个数 struct TreeNode&#123; size_t val; int degree; struct TreeNode* child1; struct TreeNode* child3; struct TreeNode* child2; ...&#125;; 当然还可以用哈希表（散列表）的形式储存树。即用顺序表将每个结点储起来，用单链表的形式将每个结点的子结点链接起来，当我们遍历树的时候就可以通过遍历顺序表形式来遍历所有子结点。 此种表示形式要寻找某个特定结点的子节点的时候非常容易定位。但是与双亲表示法相反，此种表示法在寻找双亲节点时需要遍历整个树。 孩子兄弟表示法 data|child|rightsibling与孩子表示法相似，此种表示法只是多了一个指针域指向此结点右边的兄弟结点，便于寻找兄弟结点。 2 .二叉树的概念二叉树（Binary Tree）是n(n&gt;0)个结点的有限集合，该集合或者为空集（称为空二叉树）。或者由一个根节点和两课互不相交的、分别称为根节点的左子树和右子树的二叉树构成。与树类似，二叉树相当于结点的孩子域限定为了两个（degree=2）。（递归） C语言种二叉树的结构体定义如下 struct TreeNode&#123; size_t val; struct TreeNode* left; struct TreeNode* right; &#125;; 二叉树的形式（特殊二叉树）斜树即所有的结点都沿一个方向延申（所有结点只有一个子结点且斜的方向一致），类似于链表，是线性链接的。 分为左斜树和右斜树。 满二叉树如果一颗二叉树中，所有的结点都有左子树和右子树，且所有的叶子结点都在同一层上。满二叉树一定是所有相同深度二叉树的节点最多，叶子结点最多的二叉树。 完全二叉树如果按层的顺序给满二叉树编号，完全二叉树的编号和满二叉树的编号在叶子结点未编号完之前一摸一样。由于此种特性。我们可以用数组来表示完全二叉树。 完全二叉树的数组表示：| a | b | c | d | e | f || —- | —- | —- | —- | —- | —- || 0 | 1 | 2 | 3 | 4 | 5 | 由此表示我们可以得到推论： 对于位置为$k$的结点，左子结点=2k+1，右子结点=2k+2。 最后一个非叶结点的位置为(N/2)-1，N为数组长度。 通过这些推论，我们可以通过数组表示完全二叉树且很轻松的找到一个节点的子结点，当然父母结点也可以通过倒推的方式寻找。 3. 二叉树的遍历及其代码实现树的遍历即以某种顺序对树中所有结点的数据域进行某种操作（如打印等）。其按顺序划分大致可以分为前序遍历、中序遍历、后序遍历三种情况。下面将分别介绍这三种遍历方式。 1. 中序遍历(LDR)中序遍历是从根结点开始对每一个结点按照左结点，本结点，右结点的顺序进行遍历的。如上图树的遍历方式就是： graph LR;3--&gt;1--&gt;4--&gt;0--&gt;5--&gt;2 其代码实现分为两种方式： 递归法 构造一个递归的函数，函数先中以递归形式遍历结点的左子树，再访问本结点，最后遍历结点的右子树，C语言实现代码如下： /*struct TreeNode&#123; int val; struct TreeNode *left, *right;&#125;*///树结点的定义void InorderTraversal(TreeNode* root) //中序遍历函数&#123; InorderTraversal(root-&gt;left); //遍历左子树 printf(&quot;%d&quot;, root-&gt;val); //打印本节点的值 InorderTraversal(root-&gt;right); //遍历右子树 return;&#125; 递归方式的实现比较简单，利用递归实现的时间复杂度是O(n)，空间复杂度也是O(n)。 循环迭代法 此种方法是用栈这种数据结构实现的，利用的是栈的后入先出原理($LIFO$)，我们直接来看其C语言代码实现： int IsEmpty(struct TreeNode **Stack) //判断栈空函数&#123; return *Stack == NULL ? 1 : 0; //只判断栈底元素是否为空即可&#125;void InorderTraversal(TreeNode* root)&#123; struct TreeNode *Stack[MAXN]; //定义一个栈用来获取结点 int top = 0; //栈顶 Stack[top] = NULL; //置空 struct TreeNode* temp = root; //定义一个临时变量来遍历结点 while (temp != NULL || !IsEmpty(Stack)) //栈不为空且temp不为空则持续循环 &#123; while (temp != NULL) //temp不为空指针则循环直到左叶子结点，否则将直接弹栈 &#123; Stack[top++] = temp; //temp入栈 temp = temp-&gt;left; //访问左子树 &#125; temp = Stack[--top]; Stack[top] = NULL; //弹栈并输出 printf(&quot;%d&quot;, temp-&gt;val); temp = temp-&gt;right; //访问右子树，右子树是空若栈不为空则继续弹栈，否则访问右子树 &#125; return;&#125; 这样不断的循环迭代直到所有的结点都入栈弹栈后即循环完毕中序遍历完毕。 2. 前序遍历(VLR) 递归法 由于递归法较为简单，这里直接上代码：（访问结点在前即可） void PreorderTraversal(TreeNode* root) //中序遍历函数&#123; printf(&quot;%d&quot;, root-&gt;val); //打印本节点的值 PreorderTraversal(root-&gt;left); //遍历左子树 PreorderTraversal(root-&gt;right); //遍历右子树 return;&#125; 循环迭代法 与中序遍历相同，只需简单的更换输出顺序即可。 int IsEmpty(struct TreeNode **Stack) //判断栈空函数&#123; return *Stack == NULL ? 1 : 0; //只判断栈底元素是否为空即可&#125;void PostorderTraversal(struct TreeNode *root)&#123; struct TreeNode *Stack[MAXN]; //定义一个栈用来获取结点 int top = 0; //栈顶 Stack[top] = NULL; //置空 struct TreeNode *temp = root; //定义一个临时变量来遍历结点 while (temp != NULL || !IsEmpty(Stack)) //栈不为空且temp不为空则持续循环 &#123; while (temp != NULL) //temp不为空指针则循环直到左叶子结点 &#123; printf(&quot;%d&quot;, temp-&gt;val); //先输出，后入栈 Stack[top++] = temp; //temp入栈 temp = temp-&gt;left; //访问左子树 &#125; temp = Stack[--top]; Stack[top] = NULL; //弹栈 temp = temp-&gt;right; //访问右子树，右子树是空若栈不为空则继续弹栈，否则访问右子树 &#125; return;&#125; 把输出（访问）调整到第二个循环的入栈开头即可。 3. 后序遍历(LRD) 递归法 void PostorderTraversal(TreeNode* root) //中序遍历函数&#123; PostorderTraversal(root-&gt;left); //遍历左子树 PostorderTraversal(root-&gt;right); //遍历右子树 printf(&quot;%d&quot;, root-&gt;val); //打印本节点的值 return;&#125; 循环迭代法 后续遍历的循环迭代就与前序中序不太相同了，由于是先访问左子节点和右子节点，而左节点不能直接访问到右节点，故代码需要有一定的改变，这里我们多定义一个临时变量PreAccess用来记录已经访问过的结点，防止重复访问。 int IsEmpty(struct TreeNode **Stack) //判断栈空函数&#123; return *Stack == NULL ? 1 : 0; //只判断栈底元素是否为空即可&#125;void PreorderTraversal(TreeNode* root)&#123; struct TreeNode *Stack[MAXN]; //定义一个栈用来获取结点 int top = 0; //栈顶 Stack[top] = NULL; //置空 struct TreeNode* temp = root; //定义一个临时变量来遍历结点 struct TreeNode *PreAccess = NULL; //定义一个临时变量PreAccess用来记录已经访问过右子树结点的结点 while (temp != NULL || !IsEmpty(Stack)) //栈不为空且temp不为空则持续循环 &#123; while (temp != NULL) //temp不为空指针则循环直到左叶子结点，否则将直接弹栈 &#123; Stack[top++] = temp; //temp入栈 temp = temp-&gt;left; //访问左子树 &#125; temp = Stack[top - 1]; //temp置为栈顶元素，判断右子树是否为空 if (temp-&gt;right != NULL &amp;&amp; PreAccess != temp-&gt;right) //右子树没访问过且不为空 temp = temp-&gt;right; else //否则弹栈并输出 &#123; temp = Stack[--top]; Stack[top] = NULL; printf(&quot;%d&quot;, temp-&gt;val); PreAccess = temp; //标记节点为已访问 temp = NULL; //置空，访问下一个栈顶元素 &#125; &#125; return;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://pepperrcat.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树","slug":"树","permalink":"https://pepperrcat.github.io/tags/%E6%A0%91/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://pepperrcat.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://pepperrcat.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"NEW","slug":"NEW","permalink":"https://pepperrcat.github.io/categories/NEW/"}],"tags":[{"name":"字符串匹配","slug":"字符串匹配","permalink":"https://pepperrcat.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"树","slug":"树","permalink":"https://pepperrcat.github.io/tags/%E6%A0%91/"},{"name":"begining","slug":"begining","permalink":"https://pepperrcat.github.io/tags/begining/"}]}